{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/yilia/source/js/pc.js","path":"js/pc.js","modified":0},{"_id":"themes/yilia/source/js/mobile.js","path":"js/mobile.js","modified":0},{"_id":"themes/yilia/source/js/main.js","path":"js/main.js","modified":0},{"_id":"themes/yilia/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":0},{"_id":"themes/yilia/source/js/instagram.js","path":"js/instagram.js","modified":0},{"_id":"themes/yilia/source/img/zhihu.png","path":"img/zhihu.png","modified":0},{"_id":"themes/yilia/source/img/weibo.png","path":"img/weibo.png","modified":0},{"_id":"themes/yilia/source/img/twitter.png","path":"img/twitter.png","modified":0},{"_id":"themes/yilia/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":0},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0},{"_id":"themes/yilia/source/img/rss.png","path":"img/rss.png","modified":0},{"_id":"themes/yilia/source/img/pinterest.png","path":"img/pinterest.png","modified":0},{"_id":"themes/yilia/source/img/pinboard.png","path":"img/pinboard.png","modified":0},{"_id":"themes/yilia/source/img/mail.png","path":"img/mail.png","modified":0},{"_id":"themes/yilia/source/img/linkedin.png","path":"img/linkedin.png","modified":0},{"_id":"themes/yilia/source/img/img-loading.png","path":"img/img-loading.png","modified":0},{"_id":"themes/yilia/source/img/img-err.png","path":"img/img-err.png","modified":0},{"_id":"themes/yilia/source/img/google.png","path":"img/google.png","modified":0},{"_id":"themes/yilia/source/img/github.png","path":"img/github.png","modified":0},{"_id":"themes/yilia/source/img/facebook.png","path":"img/facebook.png","modified":0},{"_id":"themes/yilia/source/img/douban.png","path":"img/douban.png","modified":0},{"_id":"themes/yilia/source/img/delicious.png","path":"img/delicious.png","modified":0},{"_id":"themes/yilia/source/img/coderwall.png","path":"img/coderwall.png","modified":0},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0},{"_id":"themes/yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0},{"_id":"themes/yilia/source/css/style.styl","path":"css/style.styl","modified":0},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":0},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0}],"Cache":[{"_id":"source/_posts/mactools.markdown","shasum":"e77e2da700a5670e77faa2b9c1dc07bf6893b1d1","modified":1507901259000},{"_id":"source/aboutme/index.html","shasum":"fa41b098af4b2d3707af9973cd0960d4cbea60ca","modified":1504508379000},{"_id":"source/aboutme/index.md","shasum":"f6bb4d3b32d4b5411f9872d591d31e8b601e6cd1","modified":1504421585000},{"_id":"source/_posts/ssh-add-mac.markdown","shasum":"cc3018e21d037531979f1e6a71432bd5decfe9c1","modified":1504507371000},{"_id":"source/timeline/index.html","shasum":"3786591c5f4052331279fcac0856ad6f7574b8a4","modified":1507901387000},{"_id":"source/timeline/index.md","shasum":"22b63bd23c9650f9bf659888323f1d65e3421256","modified":1504421585000},{"_id":"themes/yilia/README.md","shasum":"8648a81b3ae08a4accd6b0541533e662511e6400","modified":1504421585000},{"_id":"themes/yilia/_config.yml","shasum":"0232886be6d2c2bc2b23a28ec5e09b4f0eb3632e","modified":1504509986000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","shasum":"8dfb6d68aa8a0661d26c32ce1ce1f45815364c3a","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","shasum":"7f261a47ff582fcf2d2dceaab0d147d388f7ed76","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/archive.ejs","shasum":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/footer.ejs","shasum":"78ca40a95cb89e633ddfdfb4a3f8dba534798390","modified":1505036184000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","shasum":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/article.ejs","shasum":"ef8dd558f908f293c34123c0b7ff879d2fd0c09f","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/head.ejs","shasum":"2dca7a3b2d047798d21b264660852dcc59c3ca86","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","shasum":"70a9951e4e2d30aabba88e75c3fa54b9235ce6a6","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/header.ejs","shasum":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","shasum":"54fab4d3d64cb937d6baec7324ffabf9f202b883","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","shasum":"c0c988334e857a77ba455a056dfa21809e7e76a5","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","shasum":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","shasum":"d4f0e36f9a2167e91082dbd7d52425a06d2bebbf","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","shasum":"cd0af87ee781ac9c2b0e6a2a05b063d4bd497d9c","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","shasum":"da39b4ba0c0ce4e1932fd45c5aee10e8aca41f28","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","shasum":"d19dee2082528e1844bed3aa4e4bd59f15fd7a7a","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","shasum":"78612cfc091d7d861a70455a0dc8c3036e460879","modified":1504421585000},{"_id":"themes/yilia/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1504421585000},{"_id":"themes/yilia/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1504421585000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","shasum":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1504421585000},{"_id":"themes/yilia/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1504421585000},{"_id":"themes/yilia/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1504421585000},{"_id":"themes/yilia/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1504421585000},{"_id":"themes/yilia/layout/layout.ejs","shasum":"4a5566f704f3246f5ef77badddf18d2e16750328","modified":1504421585000},{"_id":"themes/yilia/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1504421585000},{"_id":"themes/yilia/package.json","shasum":"00357ef6f24eb049074da81809e98f973f528cca","modified":1504421585000},{"_id":"themes/yilia/source/css/_extend.styl","shasum":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1504421585000},{"_id":"themes/yilia/source/css/_partial/archive.styl","shasum":"8b349f1605024dcdae054e04f02d71a2e84957c2","modified":1504421585000},{"_id":"themes/yilia/source/css/_partial/article.styl","shasum":"872fc4e63509fef885c939e5fd70e6ed439beced","modified":1504421585000},{"_id":"themes/yilia/source/css/_partial/highlight.styl","shasum":"8cadf8437ce6f372802d3d28617a1ab97e7c818e","modified":1504421585000},{"_id":"themes/yilia/source/css/_partial/footer.styl","shasum":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1504421585000},{"_id":"themes/yilia/source/css/_partial/header.styl","shasum":"67e59feb18eee6026717cb440d86ab9551782628","modified":1504421585000},{"_id":"themes/yilia/source/css/_partial/instagram.styl","shasum":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1504421585000},{"_id":"themes/yilia/source/css/_partial/mobile.styl","shasum":"3a03b04ef8ac305aa5dbf7b9db99cd9377d07383","modified":1504421585000},{"_id":"themes/yilia/source/css/_partial/main.styl","shasum":"4268f759920106a576c6037264076b36018ff73b","modified":1504421585000},{"_id":"themes/yilia/source/css/_partial/page.styl","shasum":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1504421585000},{"_id":"themes/yilia/source/css/_partial/mobile-slider.styl","shasum":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1504421585000},{"_id":"themes/yilia/source/css/_partial/share.styl","shasum":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1504421585000},{"_id":"themes/yilia/source/css/_partial/scroll.styl","shasum":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1504421585000},{"_id":"themes/yilia/source/css/_partial/wheelmenu.styl","shasum":"74630c56944e27bef53ef0c0e391611a2eec2ed0","modified":1504421585000},{"_id":"themes/yilia/source/css/_util/grid.styl","shasum":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1504421585000},{"_id":"themes/yilia/source/css/_partial/tagcloud.styl","shasum":"af0115de5c6455f899a2e09225b50224982c039d","modified":1504421585000},{"_id":"themes/yilia/source/css/_util/mixin.styl","shasum":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1504421585000},{"_id":"themes/yilia/source/css/_variables.styl","shasum":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1504421585000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","shasum":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1504421585000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","shasum":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1504421585000},{"_id":"themes/yilia/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1504421585000},{"_id":"themes/yilia/source/css/style.styl","shasum":"456e8cfe3b0b0371e81848ea9b0bc7ffd5360921","modified":1504421585000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","shasum":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1504421585000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","shasum":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1504421585000},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1504421585000},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1504421585000},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1504421585000},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1504421585000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1504421585000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1504421585000},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1504421585000},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1504421585000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1504421585000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1504421585000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1504421585000},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","shasum":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1504421585000},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","shasum":"a82597493d75ea989ca586e09173cff332efe41e","modified":1504421585000},{"_id":"themes/yilia/source/img/coderwall.png","shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1504421585000},{"_id":"themes/yilia/source/img/delicious.png","shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1504421585000},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1504421585000},{"_id":"themes/yilia/source/img/douban.png","shasum":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1504421585000},{"_id":"themes/yilia/source/img/google.png","shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1504421585000},{"_id":"themes/yilia/source/img/facebook.png","shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1504421585000},{"_id":"themes/yilia/source/img/github.png","shasum":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1504421585000},{"_id":"themes/yilia/source/img/img-err.png","shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1504421585000},{"_id":"themes/yilia/source/img/img-loading.png","shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1504421585000},{"_id":"themes/yilia/source/img/linkedin.png","shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1504421585000},{"_id":"themes/yilia/source/img/pinboard.png","shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1504421585000},{"_id":"themes/yilia/source/img/mail.png","shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1504421585000},{"_id":"themes/yilia/source/img/pinterest.png","shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1504421585000},{"_id":"themes/yilia/source/img/stackoverflow.png","shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1504421585000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1504421585000},{"_id":"themes/yilia/source/img/rss.png","shasum":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1504421585000},{"_id":"themes/yilia/source/img/weibo.png","shasum":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1504421585000},{"_id":"themes/yilia/source/img/zhihu.png","shasum":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1504421585000},{"_id":"themes/yilia/source/js/instagram.js","shasum":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1504421585000},{"_id":"themes/yilia/source/img/twitter.png","shasum":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1504421585000},{"_id":"themes/yilia/source/js/mobile.js","shasum":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1504421585000},{"_id":"themes/yilia/source/js/jquery.lazyload.js","shasum":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1504421585000},{"_id":"themes/yilia/source/js/main.js","shasum":"e2633f282e377a4169649c9f17dc96036ad4fc64","modified":1504421585000},{"_id":"themes/yilia/source/js/pc.js","shasum":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1504421585000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","shasum":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1504421585000},{"_id":"public/js/pc.js","modified":1504421856133,"shasum":"fdbc039fc9ffa70815b5fc4daaa587ae29693f10"},{"_id":"public/js/mobile.js","modified":1504421856140,"shasum":"b68cc01d24e80973c48205f551da87f3f3427644"},{"_id":"public/js/main.js","modified":1504421856143,"shasum":"0640b68a76fab3c693b3cd1e4d04d14be1e53940"},{"_id":"public/js/jquery.lazyload.js","modified":1504421856144,"shasum":"c11a2e7b330d16d06feabd0a8477099adf9d6799"},{"_id":"public/js/instagram.js","modified":1504421856146,"shasum":"f19adbcc0dac33536bc6660598059048ec901882"},{"_id":"public/img/zhihu.png","modified":1504421856151,"shasum":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d"},{"_id":"public/img/weibo.png","modified":1504421856153,"shasum":"280dae3fd38086158b4a1b57edb94c06b1a5014b"},{"_id":"public/img/twitter.png","modified":1504421856155,"shasum":"14dbb8e62d056525253bc0de13acd1723da7a934"},{"_id":"public/img/stackoverflow.png","modified":1504421856157,"shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2"},{"_id":"public/img/scrollbar_arrow.png","modified":1504421856159,"shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0"},{"_id":"public/img/rss.png","modified":1504421856160,"shasum":"430fd47340e75214c081abd05cd7410cf7c71b86"},{"_id":"public/img/pinterest.png","modified":1504421856162,"shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630"},{"_id":"public/img/pinboard.png","modified":1504421856163,"shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0"},{"_id":"public/img/mail.png","modified":1504421856164,"shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7"},{"_id":"public/img/linkedin.png","modified":1504421856165,"shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c"},{"_id":"public/img/img-loading.png","modified":1504421856167,"shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031"},{"_id":"public/img/img-err.png","modified":1504421856168,"shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b"},{"_id":"public/img/google.png","modified":1504421856170,"shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d"},{"_id":"public/img/github.png","modified":1504421856171,"shasum":"b84d03b32fa388dcbf149296ebd16dce6223d48d"},{"_id":"public/img/facebook.png","modified":1504421856172,"shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54"},{"_id":"public/img/douban.png","modified":1504421856174,"shasum":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e"},{"_id":"public/img/delicious.png","modified":1504421856175,"shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd"},{"_id":"public/img/coderwall.png","modified":1504421856177,"shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1504421856178,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1504421856181,"shasum":"a82597493d75ea989ca586e09173cff332efe41e"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1504421856183,"shasum":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1504421856185,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1504421856187,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1504421856190,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1504421856192,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1504421856194,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1504421856196,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1504421856198,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1504421856202,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1504421856205,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1504421856207,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1504421856210,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1504421856212,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1504421856989,"shasum":"e56554c624d9d49e9429eeeb9222488f8df634ec"},{"_id":"public/css/fonts/fontawesome-webfont.woff","modified":1504421857281,"shasum":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832"},{"_id":"public/css/fonts/fontawesome-webfont.ttf","modified":1504421857282,"shasum":"1480b8101b02da9bc4c60341b5e185e63e585064"},{"_id":"public/css/fonts/fontawesome-webfont.svgz","modified":1504421857285,"shasum":"4bfdd33ed702e32ae01399fcc2652377f78e7626"},{"_id":"public/css/fonts/fontawesome-webfont.svg","modified":1504421857287,"shasum":"ba13657479b46daecb6336bfe376f84cef3ae58b"},{"_id":"public/css/fonts/fontawesome-webfont.eot","modified":1504421857289,"shasum":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6"},{"_id":"public/timeline/index.html","modified":1508073321098,"shasum":"8c55573c43b713f8e6142fbf1ca2fffbb1b60abb"},{"_id":"public/aboutme/index.html","modified":1508073321108,"shasum":"e18f9f45458ac5d22514e06284dd9bdaef681449"},{"_id":"public/2016/02/06/mactools/index.html","modified":1504421857365,"shasum":"ce540c251fa99cd90ce26c29efd5e8bafe847948"},{"_id":"public/2016/01/17/ssh-add-mac/index.html","modified":1504425295913,"shasum":"396e2c9741e5c7ee5f9c092439db3758270b79c1"},{"_id":"public/2015/11/29/2015-11-29-manuscript/index.html","modified":1504425295918,"shasum":"886a2d18792d80291c4bb4dd4a91d3e5894b731f"},{"_id":"public/2015/09/14/2015-09-14- 设计模式-导图/index.html","modified":1504425295926,"shasum":"81ca235498766c092b0b7c088b889480d9e4af0e"},{"_id":"public/2015/09/14/2015-09-14- 数据结构-导图/index.html","modified":1504425295932,"shasum":"3f22422629f44517fd9cae2e38567955d4bf32bf"},{"_id":"public/2015/09/14/2015-09-14- 单链表逆置/index.html","modified":1504425295942,"shasum":"8a00dccb828876c7dcf8d6c4c8b42e9069def5ff"},{"_id":"public/2015/09/14/2015-09-14- Java 基础知识-导图/index.html","modified":1504425295951,"shasum":"8713739c78e17c774fa8b6b3fff452137e4afc0c"},{"_id":"public/2015/09/13/2015-09-13- Java字符集与编码/index.html","modified":1504425295957,"shasum":"6497fad45c8d8b045aabb67e14de808e46df1838"},{"_id":"public/2015/08/30/2015-08-30- mac下抓包工具--Charles/index.html","modified":1504425295963,"shasum":"efe705c92a08be50be2f6e97eaee4c229c971d91"},{"_id":"public/2015/08/23/2015-08-15- mac下抓包工具--Debookee/index.html","modified":1504425295967,"shasum":"9cb2b9470a27dd3a3710709c7d636f91c91192de"},{"_id":"public/2015/07/25/2015-07-25- python-urllib超时/index.html","modified":1504425295973,"shasum":"267e59b4475bf36dc41956238640614dbcf66384"},{"_id":"public/2015/06/10/2015-06-10- 典型tcp攻击实验/index.html","modified":1504425295978,"shasum":"e31b4688c1bd7153ae8de922d23e21e76416b95f"},{"_id":"public/2015/06/10/2015-06-10- wireshark找不到interface/index.html","modified":1504425295983,"shasum":"033e8505de5306ce592c1b5993636bdaee11e9f0"},{"_id":"public/2015/05/03/2015-05-03- Ubuntu1204无法登录桌面/index.html","modified":1504425295988,"shasum":"0c0e1fe0a76a8f323f53c053d5b5472db3e61f5b"},{"_id":"public/2015/04/18/2015-04-18-排序算法总结/index.html","modified":1504425295997,"shasum":"04ef3bc0da4f2da098a64d8fad0f8f5969a85f18"},{"_id":"public/2015/04/18/2015-04-18-图总结/index.html","modified":1504425296002,"shasum":"b1a6f4cbfe8cad0e9d02e8d2c1e57148d03bb924"},{"_id":"public/2015/04/18/2015-04-18-二叉树总结/index.html","modified":1504425296009,"shasum":"71d99ca0f9c3d2c1028b4c4ee6baa394daebabdb"},{"_id":"public/2015/04/18/2015-04-18-算法之数组/index.html","modified":1504425296016,"shasum":"00b6c07ef0c0948e6b4abcc5af16684ebd2ebfd3"},{"_id":"public/2015/04/10/2015-04-10- 在 Mac 下安装 mysql for python/index.html","modified":1504425296030,"shasum":"ee0228aedcbefb9b6dbcba68e235c48fb1f4c197"},{"_id":"public/2014/11/29/2014-11-29-编程实现可靠数据传输原理 Go-Back-N/index.html","modified":1504425296048,"shasum":"26bcdc592417b025d1ad4bbf1860c8fa21220c40"},{"_id":"public/2014/11/27/2014-11-27-编程实现路由算法--迪杰斯特拉算法/index.html","modified":1504425296057,"shasum":"e479ef0a2f1145d2780f15d22af065aa76478a6a"},{"_id":"public/2014/10/31/2014-10-31-Java 实现 AES 算法/index.html","modified":1504425296079,"shasum":"743f30938c986644ba749d6823a5f1b3c1f0679a"},{"_id":"public/2014/10/25/2014-10-25-使用 Wireshark 抓包分析的思考/index.html","modified":1504425296084,"shasum":"9e14d41b8fbe0d1a93b411a8f56a8d8aec12fc41"},{"_id":"public/2014/10/22/2014-12-22-ThreadSynchronization/index.html","modified":1504425296089,"shasum":"1ce7c5d251c8e76f65d483ff15c539b6bccc3bea"},{"_id":"public/2014/10/20/2014-10-20-再谈用 Java 实现 SMTP 发送邮件之 Socket 编程/index.html","modified":1504425296101,"shasum":"e5900e08be67057b5b15849c5146f4ba93f7796a"},{"_id":"public/2014/10/18/2014-10-18-浅谈用 Java 搭建 web 服务器之 Socket 编程——更好的理解 Apache、Tomcat 等软件的工作模式/index.html","modified":1504425296109,"shasum":"dc1b1a6c611d0c07e0ccab5e6da8c8388f435a4b"},{"_id":"public/archives/index.html","modified":1508073321411,"shasum":"fec3781d6a07b9d4618d65dfdd39adbecdde1179"},{"_id":"public/archives/page/2/index.html","modified":1508073321455,"shasum":"385108b65929f6488255fab16096a5568042bc6c"},{"_id":"public/archives/page/3/index.html","modified":1508073321466,"shasum":"ecc2ea005fbb17cc6c5143abb8c1087f73b6b8bc"},{"_id":"public/archives/2014/index.html","modified":1508073321481,"shasum":"d8a0c2d2e63cc9f50e7d5dfbae5cc5005b51e70a"},{"_id":"public/archives/2014/10/index.html","modified":1508073321496,"shasum":"4229151a3d9b1702763f898858e5c72298c231d5"},{"_id":"public/archives/2014/11/index.html","modified":1508073321505,"shasum":"83679d979a7a87479146ccb32840b878e139c8da"},{"_id":"public/archives/2015/index.html","modified":1508073321545,"shasum":"71be905e1e86f74bcebead2d494b93d5c91b2ce6"},{"_id":"public/archives/2015/page/2/index.html","modified":1504509997371,"shasum":"413ca0d6864b52ebe8d72d4e2201701773500d04"},{"_id":"public/archives/2015/04/index.html","modified":1508073321571,"shasum":"d804807a0aa2f3c2f3a092703cfe4940f7de3d1b"},{"_id":"public/archives/2015/05/index.html","modified":1508073321583,"shasum":"e7d3a1b8ffb8c3721bb34ab523942c8d13bb0dfe"},{"_id":"public/archives/2015/06/index.html","modified":1508073321601,"shasum":"f2a175677c001a398c33c3066df4b31a7f7c0fe4"},{"_id":"public/archives/2015/07/index.html","modified":1504509997391,"shasum":"f88683ef7de2355176c799372b3d169b415e1ec3"},{"_id":"public/archives/2015/08/index.html","modified":1504509997396,"shasum":"93ceda4ec249c22c7b280be2b781e34c2483202f"},{"_id":"public/archives/2015/09/index.html","modified":1504509997399,"shasum":"a0dda397bd3ee17fcf363e4b768759ea35c52f7a"},{"_id":"public/archives/2015/11/index.html","modified":1504425296259,"shasum":"a8fd6f71d916a51c686722cedd939cfdacd3cfc1"},{"_id":"public/archives/2016/index.html","modified":1508073321618,"shasum":"09c1cd66c7bbc2a0d9ad59d8afac13a8a13ac68a"},{"_id":"public/archives/2016/01/index.html","modified":1504425296266,"shasum":"0c8a40f72e8da1b35a46fa432e519a62bccfd038"},{"_id":"public/archives/2016/02/index.html","modified":1504421857708,"shasum":"03e52cc6232676b1c9f55e701b2882a3998a22ac"},{"_id":"public/index.html","modified":1508073321815,"shasum":"5bcef09402d532397c58fff839c193dcc5ef6299"},{"_id":"public/page/2/index.html","modified":1508073321847,"shasum":"86d84de3ab1ee252b540039aa25211e6f2a43258"},{"_id":"public/page/3/index.html","modified":1508073321855,"shasum":"a17bba1b746782f476dfb1df7411ab23418faa37"},{"_id":"public/tags/Java/index.html","modified":1508073321868,"shasum":"fe76c4fa9675aeb30e42ff0734050aad0b591a7b"},{"_id":"public/tags/Socket/index.html","modified":1504425296301,"shasum":"49456217ce0a20cd96c2b96639532b340592c11a"},{"_id":"public/tags/Git/index.html","modified":1508073321873,"shasum":"a1cdc54522133358b8735636cd70fb0812ed547c"},{"_id":"public/tags/Mac/index.html","modified":1508073321888,"shasum":"99224edbd3fb5443e7d8de3fcd74924cb4931d10"},{"_id":"public/tags/icodeyou/index.html","modified":1504425296312,"shasum":"97a3d642f242fe93301f042a424ad11dd03b05f7"},{"_id":"public/tags/设计模式/index.html","modified":1504679273971,"shasum":"0c70d6a65ca619b65dca408cebb5c0351457a45c"},{"_id":"public/tags/数据结构/index.html","modified":1508073321898,"shasum":"7601a3efdca9c98545468fa45c192b03dd26b714"},{"_id":"public/tags/数据结构与算法/index.html","modified":1508073321911,"shasum":"8b91c14c2d4c457b04371703e76149ed833d6c90"},{"_id":"public/tags/Android/index.html","modified":1504668967509,"shasum":"1dc406dac209f0526b27603914b7814079235cce"},{"_id":"public/tags/Python/index.html","modified":1508073321922,"shasum":"250ae50176a812fb89482b6cafeabe495651a52a"},{"_id":"public/tags/TCP/index.html","modified":1508073321931,"shasum":"091efa2536d62a3695591ffa6aaa1e622536f658"},{"_id":"public/tags/netwox/index.html","modified":1508073321938,"shasum":"94d00b2c4e407d78bda00d8020cac2b45be9bec6"},{"_id":"public/tags/Linux/index.html","modified":1508073321954,"shasum":"29548610825d5e3b9774e4598cff53a73fe4ed1d"},{"_id":"public/tags/Wireshark/index.html","modified":1508073321964,"shasum":"5fcca57b1176a99756615520ac60a5f8df45798f"},{"_id":"public/tags/算法/index.html","modified":1508073321969,"shasum":"dbd5c84edb2e32cbd18e0a0ee32b1ef52ee3efee"},{"_id":"public/tags/Mysql/index.html","modified":1508073321974,"shasum":"e946cbd0c87c51e01471354bb03bf11b89dd9ad5"},{"_id":"public/tags/GBN/index.html","modified":1508073321980,"shasum":"b944302db3a9bca6c7bf9fd64663131a2260bf14"},{"_id":"public/tags/路由算法/index.html","modified":1508073321987,"shasum":"d273437ada57b4720209e2de753fbf8aa9185c27"},{"_id":"public/tags/迪杰斯特拉/index.html","modified":1508073321997,"shasum":"18b74e2583772c9017db150149973a74cab96640"},{"_id":"public/tags/AES/index.html","modified":1508073322003,"shasum":"1970d8b93aed5ea7ac524408eeb577ebabec1b23"},{"_id":"public/tags/SMTP/index.html","modified":1504425296405,"shasum":"f8c01d35c9ff6907e81c857af2d403aae8f6d59e"},{"_id":"public/2017/08/06/mactools/index.html","modified":1504425295904,"shasum":"fb33d722bd721376aede938c1c303b67e4b76dc8"},{"_id":"public/archives/2017/index.html","modified":1508073321697,"shasum":"225e569a9c6273deed0597efd630ce956a7a198b"},{"_id":"public/archives/2017/08/index.html","modified":1505036200868,"shasum":"0cc51d02483b7903f2e422689b9c2479680fd301"},{"_id":"public/2017/08/18/test/index.html","modified":1504425295881,"shasum":"ae8dafae65bf0abbef67ae8ce9331c76001141aa"},{"_id":"source/_posts/Java 基础知识-导图.markdown","shasum":"acf61001e2282109f89c0e5375f86a8ebefa0b48","modified":1504679222000},{"_id":"source/_posts/Java 实现 AES 算法.markdown","shasum":"db515b89e81f3982947c696a07a7670790895aeb","modified":1504507938000},{"_id":"source/_posts/Java字符集与编码.markdown","shasum":"f4010a2c8e664e518fc4c5abe3031b059e7c4cbc","modified":1504510143000},{"_id":"source/_posts/Ubuntu1204无法登录桌面.markdown","shasum":"956402fefbfbe9f8be968dc9a7ceafb5b5c5ad4d","modified":1504507725000},{"_id":"source/_posts/mac下抓包工具--Charles.markdown","shasum":"ba77ffbab8cc0292a2fe197c58c2229c77166122","modified":1504510158000},{"_id":"source/_posts/mac下抓包工具--Debookee.markdown","shasum":"7eeddc5167f87f7410d6891bc671e27256fc9032","modified":1504510166000},{"_id":"source/_posts/python-urllib超时.markdown","shasum":"c9a68fb43b3baee6932d1d3144842bbac3daf80c","modified":1504510179000},{"_id":"source/_posts/wireshark找不到interface.markdown","shasum":"49f302296e33ae9eb60c411322ceb481c91f33f1","modified":1504507665000},{"_id":"source/_posts/二叉树总结.markdown","shasum":"0c18cd8e6bd96ecb795abd852ae33a6a57a077d9","modified":1508145795123},{"_id":"source/_posts/使用 Wireshark 抓包分析的思考.markdown","shasum":"ec3ddcfe41d4fa528908657804a6fa1e86811366","modified":1504507986000},{"_id":"source/_posts/典型tcp攻击实验.markdown","shasum":"81a5149e3a84ac4a91fcc9be46bbda0fd014396e","modified":1504507711000},{"_id":"source/_posts/单链表逆置.markdown","shasum":"0ce7f2603f95fa56bb36137f06d2f4a9c629a92d","modified":1508505251000},{"_id":"source/_posts/图总结.markdown","shasum":"c47517072114001420733d525822248fb91dbd4a","modified":1508505763000},{"_id":"source/_posts/在 Mac 下安装 mysql for python.markdown","shasum":"d9c50cff3b33f7d21b74c8ef45b08f3bc573d43a","modified":1504507800000},{"_id":"source/_posts/排序算法总结.markdown","shasum":"015dfd76d6f396e0639cb9906367186ec8e7e2d2","modified":1508505531000},{"_id":"source/_posts/数据结构-导图.markdown","shasum":"0b35db70d2176a7aa537875d3c0666bd612ca8f9","modified":1504509829000},{"_id":"source/_posts/算法之数组.markdown","shasum":"909d4083b9b56a167b42b5958b497232f35b2128","modified":1504507743000},{"_id":"source/_posts/编程实现可靠数据传输原理 Go-Back-N.markdown","shasum":"31a636ba06dd8b3bb35ae00094d76d54bf62bf72","modified":1504507883000},{"_id":"source/_posts/编程实现路由算法--迪杰斯特拉算法.markdown","shasum":"86e147170171f8370f803922d5f4df9647d0fcb1","modified":1504507925000},{"_id":"public/2017/08/26/mactools/index.html","modified":1505036200168,"shasum":"f96a6fa7d11fd44e96d4abea8eb4dce4912cdade"},{"_id":"public/2017/06/17/ssh-add-mac/index.html","modified":1508073321152,"shasum":"d907d5b183f175bf173d2588f9b41cc917b7e3ca"},{"_id":"public/2015/09/14/Java 基础知识-导图/index.html","modified":1504508685402,"shasum":"3d5522c79ff63eb6aa09e6224fab0b9b0e4cf697"},{"_id":"public/2015/09/14/设计模式-导图/index.html","modified":1504508685408,"shasum":"2a92c411c2b8c21b45d40a65521b87a4041d31f5"},{"_id":"public/2015/09/14/单链表逆置/index.html","modified":1504508685424,"shasum":"9207640cf2ca10448f89565abbae65ecd8f857fb"},{"_id":"public/2015/09/14/数据结构-导图/index.html","modified":1504508685433,"shasum":"87c923e555e3495e2e88ed8ddca38da0fd7acf3d"},{"_id":"public/2015/09/13/Java字符集与编码/index.html","modified":1504509997217,"shasum":"17bdc3866c9cd618ed884a9ac65f1609d4be0ef4"},{"_id":"public/2015/08/30/mac下抓包工具--Charles/index.html","modified":1504509997224,"shasum":"afb0c1f9e74cf3ccfc318e56dabd148317bda4e1"},{"_id":"public/2015/08/23/mac下抓包工具--Debookee/index.html","modified":1504509997229,"shasum":"916dc324680fc1b99af4dd7ad75bf6f6d97c37ce"},{"_id":"public/2015/07/25/python-urllib超时/index.html","modified":1504509997233,"shasum":"069e10f04f5845c985249d9b07c6ec12d9349778"},{"_id":"public/2015/06/10/典型tcp攻击实验/index.html","modified":1508073321259,"shasum":"4e1e4dd03ddca28609aa4f61dd3016fd12f41c89"},{"_id":"public/2015/06/10/wireshark找不到interface/index.html","modified":1508073321242,"shasum":"4acfb826ce6561d1987458ecbb353a4523c7f91d"},{"_id":"public/2015/05/03/Ubuntu1204无法登录桌面/index.html","modified":1508073321266,"shasum":"fd3edd0fc0bfbd997c02ac9691de12760b40d8c9"},{"_id":"public/2015/04/18/二叉树总结/index.html","modified":1508145802396,"shasum":"2a29bdef205920d4ce848d45a643f03f480d3be5"},{"_id":"public/2015/04/18/排序算法总结/index.html","modified":1508505825427,"shasum":"73b1de81388f92611f2b0ab92e6fad6963a169d4"},{"_id":"public/2015/04/18/算法之数组/index.html","modified":1508073321315,"shasum":"019834ec37b510b65997cbfab79960597ae809d5"},{"_id":"public/2015/04/18/图总结/index.html","modified":1508505825409,"shasum":"808d9fde664444210bbc780f7c50024c0b3a12dd"},{"_id":"public/2015/04/10/在 Mac 下安装 mysql for python/index.html","modified":1508073321323,"shasum":"0e417600afd6cd5ba5df5f3678c1fe1eed5b283b"},{"_id":"public/2014/11/29/编程实现可靠数据传输原理 Go-Back-N/index.html","modified":1508073321336,"shasum":"38b413679f6a8af8eb898ed51f46c7794a7be0ff"},{"_id":"public/2014/11/27/编程实现路由算法--迪杰斯特拉算法/index.html","modified":1508073321348,"shasum":"aae77b1aec1d4416db1c55845798e61a5ff92278"},{"_id":"public/2014/10/31/Java 实现 AES 算法/index.html","modified":1508073321356,"shasum":"d520f20dae6561cccaa1d63b12e418a41e025557"},{"_id":"public/2014/10/25/使用 Wireshark 抓包分析的思考/index.html","modified":1508073321366,"shasum":"ddb757dda5f1939e66f6bbe05eb668e3ed7bd876"},{"_id":"public/archives/2017/06/index.html","modified":1508073321755,"shasum":"0fc5fceef86eb8bd02df2c22dee3da675a1f605b"},{"_id":"public/2017/05/14/Java 基础知识-导图/index.html","modified":1508073321160,"shasum":"2e9a167ef00173f0270a3f34020fef803e7155a1"},{"_id":"public/2017/04/12/设计模式-导图/index.html","modified":1504679273645,"shasum":"6b3724a4c9b3f10743adf09229e9d3c7489ce80b"},{"_id":"public/2017/03/02/单链表逆置/index.html","modified":1508505825285,"shasum":"fd551346e8f49b7fa883145eb7ca00054d185da9"},{"_id":"public/2017/02/18/数据结构-导图/index.html","modified":1508073321202,"shasum":"73d01f8a73b811a2a264af440b7f4cde66e808fd"},{"_id":"public/archives/2017/02/index.html","modified":1508073321707,"shasum":"0970801dba498ed9378adcb6efef9030652f1d40"},{"_id":"public/archives/2017/03/index.html","modified":1508073321728,"shasum":"57389f23ff0fa08f23e917ce4cb88637f10e44c7"},{"_id":"public/archives/2017/04/index.html","modified":1504679273926,"shasum":"5b84f88542c1714bdeabee77107a8e508a6a3c40"},{"_id":"public/archives/2017/05/index.html","modified":1508073321738,"shasum":"22c104a67685a30b0fefe22a230fe3372e1e09a6"},{"_id":"public/2016/09/13/Java字符集与编码/index.html","modified":1508073321210,"shasum":"1ebf19765390123e15c01cca62165855f4a414fd"},{"_id":"public/2016/08/30/mac下抓包工具--Charles/index.html","modified":1508073321216,"shasum":"81f107a6086a42d462cd9b539797469e55622b26"},{"_id":"public/2016/07/23/mac下抓包工具--Debookee/index.html","modified":1508073321225,"shasum":"f65357a1e60325eb41a3b1a8cbf05c5cb7b75519"},{"_id":"public/2016/04/25/python-urllib超时/index.html","modified":1508073321234,"shasum":"208b01b044fddab0f184fd75bb3853eda42cc179"},{"_id":"public/archives/2016/04/index.html","modified":1508073321626,"shasum":"1d6cdd3e0a922f39b8f4591a807214e0f6ac769a"},{"_id":"public/archives/2016/07/index.html","modified":1508073321636,"shasum":"af0f707d85e68255b8e3c7ff1661962c55bed324"},{"_id":"public/archives/2016/08/index.html","modified":1508073321650,"shasum":"583701c39f8677cf2c990fc6e326cbe5fc153e4c"},{"_id":"public/archives/2016/09/index.html","modified":1508073321663,"shasum":"714f069fc298534406f4a9f2892c3846249ae074"},{"_id":"source/_posts/jenkins.markdown","shasum":"e955ef265f8ef11ab4687fa57914deb57c93dc2f","modified":1504511162000},{"_id":"public/2017/06/30/jenkins/index.html","modified":1508073321142,"shasum":"d84704290c78e94c2275c39b368252e37fcf2442"},{"_id":"public/tags/Jenkins/index.html","modified":1508073322014,"shasum":"078ffa87d6d2469f32852ad42998b1aac798714d"},{"_id":"public/2017/07/20/js版的各种排序/index.html","modified":1505036200188,"shasum":"2834bc41f55ee419d453239427471ba17e6aee75"},{"_id":"public/archives/2017/07/index.html","modified":1505036200860,"shasum":"5e40f83ce98cde69f6fdd529c1e0fe6a25dfb7bc"},{"_id":"public/tags/JavaScript/index.html","modified":1505036201106,"shasum":"1795ba11ff2f2a61a838c31e9bc41c1e11bbcb6a"},{"_id":"public/2017/09/26/mactools/index.html","modified":1508073321127,"shasum":"858ccddaf5864a809bed7386b5a0feb67a349488"},{"_id":"public/archives/2017/09/index.html","modified":1508073321789,"shasum":"3f9fe593680ea9b3fcdf799d100944f48d1256d1"},{"_id":"source/_posts/linux-command.markdown","shasum":"ecb8b48697a835697eaafaca37f65915e4b8a45f","modified":1508124385235},{"_id":"public/2017/03/12/linux-command/index.html","modified":1508124403331,"shasum":"3d8c159a3a241762b0c81863bea64e0cd0f357e4"}],"Category":[],"Data":[],"Page":[{"title":"timeline","date":"2016-11-28T12:18:29.000Z","_content":"","source":"timeline/index.md","raw":"title: timeline\ndate: 2016-11-28 20:18:29\n---","updated":"2017-09-03T06:53:05.000Z","path":"timeline/index.html","comments":1,"layout":"page","_id":"cj74dxev20005lr01k70kbihm"},{"layout":"page","title":"时间线","date":"2016-11-28T12:18:00.000Z","comments":1,"sharing":true,"footer":true,"_content":"\n<h4>2017-10 研二下 北京交通大学校一等学习奖学金</h4>\n<h4>2017-03 研一下 北京交通大学校二等学习奖学金；校优秀团员、优秀党员</h4>\n<h4>2016-09 研一 北京交通大学计算机</h4>\n<h4>2016-01~07 大四下 一下科技秒拍运营部 前端开发实习生</h4>\n<h4>2015-07 大三下，北京交通大学校优秀心理委员、优秀团员、计算机学院优秀团干</h4>\n<h4>2014-12 大三上，北京交通大学计算机应用大赛一等奖</h4>\n<h4>2014-08 大二下，微信头像 Anyone+ 应用 前24h PV：40W UIP：8W</h4>\n<h4>2014-08 大二下，创意表白应用“捅破窗户纸” 前24h PV：10W UIP：3W</h4>\n<h4>2014-04 大二下，入手zhouwut.cn并着手搭建个人网站</h4>\n<h4>2012-11 大一上，北京交通大学校ACM竞赛专业组二等奖</h4>\n<h4>2012，大一 北京交通大学信息安全</h4>","source":"timeline/index.html","raw":"---\nlayout: page\ntitle: \"时间线\"\ndate: 2016-11-28 20:18\ncomments: true\nsharing: true\nfooter: true\n---\n\n<h4>2017-10 研二下 北京交通大学校一等学习奖学金</h4>\n<h4>2017-03 研一下 北京交通大学校二等学习奖学金；校优秀团员、优秀党员</h4>\n<h4>2016-09 研一 北京交通大学计算机</h4>\n<h4>2016-01~07 大四下 一下科技秒拍运营部 前端开发实习生</h4>\n<h4>2015-07 大三下，北京交通大学校优秀心理委员、优秀团员、计算机学院优秀团干</h4>\n<h4>2014-12 大三上，北京交通大学计算机应用大赛一等奖</h4>\n<h4>2014-08 大二下，微信头像 Anyone+ 应用 前24h PV：40W UIP：8W</h4>\n<h4>2014-08 大二下，创意表白应用“捅破窗户纸” 前24h PV：10W UIP：3W</h4>\n<h4>2014-04 大二下，入手zhouwut.cn并着手搭建个人网站</h4>\n<h4>2012-11 大一上，北京交通大学校ACM竞赛专业组二等奖</h4>\n<h4>2012，大一 北京交通大学信息安全</h4>","updated":"2017-10-13T13:29:47.000Z","path":"timeline/index.html","_id":"cj74dxev40006lr01ei2fpk2k"},{"title":"aboutme","date":"2015-08-23T16:01:51.000Z","_content":"","source":"aboutme/index.md","raw":"title: aboutme\ndate: 2015-08-24 00:01:51\n---\n","updated":"2017-09-03T06:53:05.000Z","path":"aboutme/index.html","comments":1,"layout":"page","_id":"cj74dxev60007lr01f8e365m9"},{"layout":"page","title":"About","date":"2016-03-27T10:41:00.000Z","comments":1,"sharing":true,"footer":true,"_content":"\n<h4>会弹钢琴&会敲键盘的女程序媛</h4>","source":"aboutme/index.html","raw":"---\nlayout: page\ntitle: \"About\"\ndate: 2016-03-27 18:41\ncomments: true\nsharing: true\nfooter: true\n---\n\n<h4>会弹钢琴&会敲键盘的女程序媛</h4>","updated":"2017-09-04T06:59:39.000Z","path":"aboutme/index.html","_id":"cj74dxev70008lr017rwbdons"}],"Post":[{"title":"Mac 上 ssh-add 永久将私钥添加到 Keychain","date":"2017-06-17T07:04:44.000Z","_content":"\n两种连接 Git 服务器的方式，分别为 HTTPS 和 SSH，显然更推荐后者，所以我们经常使用命令 `ssh-keygen -t rsa -C “zhouwt7@163.com”` 来生成 SSH 的公钥和私钥，之后执行 `ssh-add privateKey` 将 SSH 的私钥添加进去，但是发现了一个问题就是`每次重启电脑后都需要重新 ssh-add`，显然每次重启后都需要重新添加让我等程序员肯定受不了，解决办法就是在添加 ssh 私钥的时候使用如下命令： `ssh-add -K privateKey`，即可一劳永逸将私钥添加进 Mac 本身的钥匙串中，即 Keychain。下面简单解释下原理。\n\n<!--more-->\n\n首先得了解一件事：ssh-add 这个命令不是用来永久性的记住你所使用的私钥的。实际上，它的作用只是把你指定的私钥添加到 ssh-agent 所管理的一个 session 当中。而 ssh-agent 是一个用于存储私钥的临时性的 session 服务，也就是说当你重启之后，ssh-agent 服务也就重置了，session 会话也就失效了。\n\n既然 ssh-agent 是个临时的，那么对于 Mac 来说，哪里可以永久存储的，显然就是 Keychain 了，在执行 `ssh-add -K privateKey` 后可以打开偏好设置中的 Keychain来观察一下前后的变化，是不是多出了 SSH 的条目，见下图。\n\n![ssh-add-K](http://7xivx9.com1.z0.glb.clouddn.com/ssh-add-K.png)","source":"_posts/ssh-add-mac.markdown","raw":"title: Mac 上 ssh-add 永久将私钥添加到 Keychain\ndate: 2017-06-17 15:04:44 \ntags: Git\n----\n\n两种连接 Git 服务器的方式，分别为 HTTPS 和 SSH，显然更推荐后者，所以我们经常使用命令 `ssh-keygen -t rsa -C “zhouwt7@163.com”` 来生成 SSH 的公钥和私钥，之后执行 `ssh-add privateKey` 将 SSH 的私钥添加进去，但是发现了一个问题就是`每次重启电脑后都需要重新 ssh-add`，显然每次重启后都需要重新添加让我等程序员肯定受不了，解决办法就是在添加 ssh 私钥的时候使用如下命令： `ssh-add -K privateKey`，即可一劳永逸将私钥添加进 Mac 本身的钥匙串中，即 Keychain。下面简单解释下原理。\n\n<!--more-->\n\n首先得了解一件事：ssh-add 这个命令不是用来永久性的记住你所使用的私钥的。实际上，它的作用只是把你指定的私钥添加到 ssh-agent 所管理的一个 session 当中。而 ssh-agent 是一个用于存储私钥的临时性的 session 服务，也就是说当你重启之后，ssh-agent 服务也就重置了，session 会话也就失效了。\n\n既然 ssh-agent 是个临时的，那么对于 Mac 来说，哪里可以永久存储的，显然就是 Keychain 了，在执行 `ssh-add -K privateKey` 后可以打开偏好设置中的 Keychain来观察一下前后的变化，是不是多出了 SSH 的条目，见下图。\n\n![ssh-add-K](http://7xivx9.com1.z0.glb.clouddn.com/ssh-add-K.png)","slug":"ssh-add-mac","published":1,"updated":"2017-09-04T06:42:51.000Z","_id":"cj74dxev90009lr01giyko6nv","comments":1,"layout":"post","photos":[],"link":""},{"title":"我的 Mac 清单","date":"2017-09-26T07:04:44.000Z","_content":"\n使用 Mac 一年了，从各种地方搜集来了很多好用的软件，特此在此记录一下，既方便自己积累用，也供他人参考，本篇长期不定期更新。\n\n<!--more-->\n\n### 常用指数说明\n★★★★★ ： 每次开机必须要运行的\n★★★★  ： 需要时运行，且使用频率很好\n★★★   ： 需要时才会运行\n★★    ： 基本很少打开，但是还不会到卸载的地步\n\n## 开发相关\n\n| 常用指数 | 名称   | 简介   |\n| ---- | ---- | ---- |\n|   ★★★★★   |   Dash   |   开发文档速查   |\n|   ★★★★★   |   Google Chrome Canary   |   可以与稳定版Chrome并存，我一般用来翻墙用   |\n|   ★★★★★   |   Kaleidoscope   |   Diff工具，与Git结合   |\n|   ★★★★★   |   Sublime Text   |      |\n|   ★★★★★   |   Bartender   |   让你的菜单栏右上角图标更简洁   |\n|   ★★★★★   |   iTerm + ohmyzsh   |   再好用不过的终端   |\n|   ★★★★★   |   Quiver   |   适合程序员的记录工具   |\n|   ★★★★★   |   SourceTree   |   Git管理工具，程序员离不开 Git 了吧   |\n|   ★★★★   |   Charles   |   一般用于手机代理抓包   |\n|   ★★★   |   SmartFinder for Android   |   锤子出品，Android手机文件传输   |\n|   ★★★   |   VMware Fusion   |   虚拟机   |\n|   ★★★   |   Sip   |   屏幕取色工具，用于自己验证颜色是否符合设计师的要求   |\n|   ★★★   |   Typora   |   MD写作工具   |\n|   ★★   |   Go2Shell   |   以Finder中的直接打开终端   |\n|   ★★   |   ArgoUML、StarUML   |   UML图   |\n|   ★★   |   SQLite Professional   |   SQLite数据库工具   |\n|   ★★   |   Debookee   |   局域网抓包神奇，基于ARP欺骗   |\n|   ★★   |   Cyberduck   |   FTP工具   |\n|   ★   |   Wireshark   |   通用抓包   |\n\n\n## 效率类\n\n| 常用指数 | 名称   | 简介   |\n| ---- | ---- | ---- |\n|   ★★★★★★★★★★   |   Alfred 2 2.x [SP]   |   不解释   |\n|   ★★★★★   |   1Password    |   保存密码   |\n|   ★★★★★   |   Paste   |   剪贴板神奇   |\n|   ★★★★★   |   Contexts   |   窗口切换工具   |\n|   ★★★★   |   Snip   |   截图工具，腾讯出品   |\n\n\n## 工具类  \n\n| 常用指数 | 名称   | 简介   |\n| ---- | ---- | ---- |\n|   ★★★★★   |   moom   |   窗口大小调整   |\n|   ★★★★★   |   Scroll Reverser   |   鼠标反转   |\n|   ★★★★★   |   Synergy   |   用一个鼠标控制PC&Mac&Linux   |\n|   ★★★★★   |   Unclutter   |   临时记录、临时文件存储   |\n|   ★★★★★   |   The Unarchiver   |   解压   |\n|   ★★★★★   |   Karabiner   |   键盘映射工具，待出个博客专门来讲解一下   |\n|   ★★★★   |   Reeder   |   RSS阅读器   |\n|   ★★★★   |   Pocket   |   稍候阅读   |\n|   ★★★   |   licecap   |   Gif屏幕录制   |\n|   ★★★   |   MindMaple Lite   |   思维导图   |\n|   ★★   |   pixeImator   |   图片处理   |\n|   ★★   |   ScreenFlow   |   屏幕录制   |\n|   ★★   |   Camtasia 2    |   屏幕录制   |\n|   ★★   |   Caffeine   |   保持电脑不进入睡眠   |\n|   ★★   |   Mark Man   |   设计师必备工具，图片标注、测量   |\n\n## 一些小技巧\n\n给Dock加分隔线\nhttp://www.jianshu.com/p/29749e8a759e\n\n纯文本粘贴\nShift + Option + Cmd + V\n\n命令行中\ndate   ：显示当前日期，如 2016年 2月27日 星期六 10时16分55秒 CST\ncal    ：显示当月日历\nuptime ：显示当前开机时间，如 10:17  up 20 mins, 2 users, load averages: 1.69 1.65 1.27\n\n开挂的 Option\n右键文件，按住 Option 可以设置默认程序、拷贝路径、显示检查器\n点击右上角的电源、网络等按住Option看到更多信息\n\nAlfred Workflow\nChrome Bookmarks、Copy Path、Dash、Kill Process、SourceTree、Youdao Translate","source":"_posts/mactools.markdown","raw":"title: 我的 Mac 清单\ndate: 2017-09-26 15:04:44 \ntags: Mac\n----\n\n使用 Mac 一年了，从各种地方搜集来了很多好用的软件，特此在此记录一下，既方便自己积累用，也供他人参考，本篇长期不定期更新。\n\n<!--more-->\n\n### 常用指数说明\n★★★★★ ： 每次开机必须要运行的\n★★★★  ： 需要时运行，且使用频率很好\n★★★   ： 需要时才会运行\n★★    ： 基本很少打开，但是还不会到卸载的地步\n\n## 开发相关\n\n| 常用指数 | 名称   | 简介   |\n| ---- | ---- | ---- |\n|   ★★★★★   |   Dash   |   开发文档速查   |\n|   ★★★★★   |   Google Chrome Canary   |   可以与稳定版Chrome并存，我一般用来翻墙用   |\n|   ★★★★★   |   Kaleidoscope   |   Diff工具，与Git结合   |\n|   ★★★★★   |   Sublime Text   |      |\n|   ★★★★★   |   Bartender   |   让你的菜单栏右上角图标更简洁   |\n|   ★★★★★   |   iTerm + ohmyzsh   |   再好用不过的终端   |\n|   ★★★★★   |   Quiver   |   适合程序员的记录工具   |\n|   ★★★★★   |   SourceTree   |   Git管理工具，程序员离不开 Git 了吧   |\n|   ★★★★   |   Charles   |   一般用于手机代理抓包   |\n|   ★★★   |   SmartFinder for Android   |   锤子出品，Android手机文件传输   |\n|   ★★★   |   VMware Fusion   |   虚拟机   |\n|   ★★★   |   Sip   |   屏幕取色工具，用于自己验证颜色是否符合设计师的要求   |\n|   ★★★   |   Typora   |   MD写作工具   |\n|   ★★   |   Go2Shell   |   以Finder中的直接打开终端   |\n|   ★★   |   ArgoUML、StarUML   |   UML图   |\n|   ★★   |   SQLite Professional   |   SQLite数据库工具   |\n|   ★★   |   Debookee   |   局域网抓包神奇，基于ARP欺骗   |\n|   ★★   |   Cyberduck   |   FTP工具   |\n|   ★   |   Wireshark   |   通用抓包   |\n\n\n## 效率类\n\n| 常用指数 | 名称   | 简介   |\n| ---- | ---- | ---- |\n|   ★★★★★★★★★★   |   Alfred 2 2.x [SP]   |   不解释   |\n|   ★★★★★   |   1Password    |   保存密码   |\n|   ★★★★★   |   Paste   |   剪贴板神奇   |\n|   ★★★★★   |   Contexts   |   窗口切换工具   |\n|   ★★★★   |   Snip   |   截图工具，腾讯出品   |\n\n\n## 工具类  \n\n| 常用指数 | 名称   | 简介   |\n| ---- | ---- | ---- |\n|   ★★★★★   |   moom   |   窗口大小调整   |\n|   ★★★★★   |   Scroll Reverser   |   鼠标反转   |\n|   ★★★★★   |   Synergy   |   用一个鼠标控制PC&Mac&Linux   |\n|   ★★★★★   |   Unclutter   |   临时记录、临时文件存储   |\n|   ★★★★★   |   The Unarchiver   |   解压   |\n|   ★★★★★   |   Karabiner   |   键盘映射工具，待出个博客专门来讲解一下   |\n|   ★★★★   |   Reeder   |   RSS阅读器   |\n|   ★★★★   |   Pocket   |   稍候阅读   |\n|   ★★★   |   licecap   |   Gif屏幕录制   |\n|   ★★★   |   MindMaple Lite   |   思维导图   |\n|   ★★   |   pixeImator   |   图片处理   |\n|   ★★   |   ScreenFlow   |   屏幕录制   |\n|   ★★   |   Camtasia 2    |   屏幕录制   |\n|   ★★   |   Caffeine   |   保持电脑不进入睡眠   |\n|   ★★   |   Mark Man   |   设计师必备工具，图片标注、测量   |\n\n## 一些小技巧\n\n给Dock加分隔线\nhttp://www.jianshu.com/p/29749e8a759e\n\n纯文本粘贴\nShift + Option + Cmd + V\n\n命令行中\ndate   ：显示当前日期，如 2016年 2月27日 星期六 10时16分55秒 CST\ncal    ：显示当月日历\nuptime ：显示当前开机时间，如 10:17  up 20 mins, 2 users, load averages: 1.69 1.65 1.27\n\n开挂的 Option\n右键文件，按住 Option 可以设置默认程序、拷贝路径、显示检查器\n点击右上角的电源、网络等按住Option看到更多信息\n\nAlfred Workflow\nChrome Bookmarks、Copy Path、Dash、Kill Process、SourceTree、Youdao Translate","slug":"mactools","published":1,"updated":"2017-10-13T13:27:39.000Z","_id":"cj74dxevb000clr01zvrbfbtt","comments":1,"layout":"post","photos":[],"link":""},{"title":"Java 基础知识 - 知识导图","date":"2017-05-14T14:18:44.000Z","_content":"\nJava 基础知识知识导图\n\n<!--more-->\n\n# Java 基础知识\n\n![Java 基础知识](http://7xivx9.com1.z0.glb.clouddn.com/summaryJava基础知识.png)","source":"_posts/Java 基础知识-导图.markdown","raw":"title: Java 基础知识 - 知识导图\ndate: 2017-05-14 22:18:44\ntags: Java\n---\n\nJava 基础知识知识导图\n\n<!--more-->\n\n# Java 基础知识\n\n![Java 基础知识](http://7xivx9.com1.z0.glb.clouddn.com/summaryJava基础知识.png)","slug":"Java 基础知识-导图","published":1,"updated":"2017-09-06T06:27:02.000Z","_id":"cj75tmhsg0000oa5x7blttoma","comments":1,"layout":"post","photos":[],"link":""},{"layout":"post","title":"编程实现路由算法--迪杰斯特拉算法","date":"2014-11-27T07:20:33.000Z","comments":1,"_content":"\n路由算法有很多，本篇采用迪杰斯特拉最短路径法实现简单的路由算法。可能很多人一看到这个就会想到数据结构了，想到数据结构中必须要建立图的结构就很头疼，今天这种写法可以先不采用数据结构书上的写法，也可以实现相同的功能，毕竟，咱们的重点是要学习使用迪杰斯特拉算法，而不是构建图结构。\n\n<!--more-->\n\n首先先来说一下迪杰斯特拉算法，从大概念上来说，该方法属于一种贪心算法，即当加进一个点后，算其相邻所有点的最短路径。详细过程如下：\n\n如下图，要计算其中 点1 到其余各点的最短路径\n\n![image](http://img.blog.csdn.net/20141127161359885)\n\n总的计算过程见下表\n\n![image](http://img.blog.csdn.net/20141127161400447)\n\n表中红颜色代表当前行未加入到点集中的最小值，蓝颜色代表和上一个新加入点集中的点相邻的点，可能这样说还不是很清楚，就看下面的具体过程了。\n\n第一步：初始化，把和 点1 相连的所有点的D（i）初始化，从图中可以看出，1和2、4、5相连，所以D（2）=10，D（4）=30，D（5）=100，点1和点3不直接相连，所以D（3）=65535，代表无穷大（在java里，可以用Integer.MAX_VALUE来表示无穷大）。由于现在点集中只有点1，所以找出刚才步骤1那行中D（i）最小的点，为点2（图中红色标明），将其加入到点集中。\n\n第二步：此时点集中新加入了点2，则以点2为出发点，从图中看到只有点3与其相连，所以这一步中只需要更新D（3）即可，D（3）= min{D（3）， D（2）+ d（2,3）}，即D（3）= min{65535， 10+ 50} = 60，更新D（3）=60，其余点不变。这行更新完毕，发现未加入到点集中的D（4）最小，所以将点4加入到点集中。\n\n第三步： 此时点集中新加入了点4，则以点4为出发点，从图中看到点3和点5与其相连，所以这一步需要更新D（3）和D（5）的值，D（3）= min{D（3）， D（4）+ d（4,3）} ，即D（3） = min{60, 30+20} = 50；D（5） = min{D（5）， D（4）+ d（4,5）} = min {100， 30 + 60} = 90。此时这一行其他数据不用变，此行更新完毕，找出未加入到点集中的 点3、点5 中的最小值，应该是点3，加入到点集中。\n\n第四步，此时点集中新加入了点3，则以点3为出发点，发现点5与其相连，只需要更新D（5）即可。D（5） = min{D（5）， D（3）+ d（3,5）} = min {90， 50 + 10} = 60，此时这行更新完毕，只有最后一个 点5 未加入到点集中了，所以将其加入。\n\n第五步，此时点集中新加入了点5，则以点5为出发点，发现根本没有点与其相连，甚好，此行就不用再更新了。\n\n第六步，机智的我发现所有点都被包含在了点集中，所以本次迪杰斯特拉算法就到此结束了。\n\n剩下的就是代码实现了。\n\n用一个二维数组d[i][j]来存从第i个点到第j个点的路径权重，其中65535为无穷大； 用一个一维数组f[i]才表示从第1个节点到第i个节点的最短路径。\n\n```\n/* \n*周梧桐   12283026\n*实验四 编程实现路由算法 \n*/ \npublic class Dijkstra_Router { \n    public static void main(String[] args) throws IOException { \n        Scanner scanner = new Scanner(System.in); \n        int i, j; \n        int n = scanner.nextInt(); \n        //因为第0个单元我不用，所以就多开了两个空间 \n        int[][] d = new int [n+2][n+2];  //二维矩阵存储点之间的距离 \n        int []book = new int [n+2];    //标志数组，book[i]=0代表第i个点未在点集中，book[i]=1代表第i个点在点集中 \n        int []f = new int[n+2];  //f[i]表示从第1个节点到第i个节点的最短路径 \n        int min = 65535, min_pos = 0;   //最小值设置为65535，为了比较出最小值， min_pos表示当前步骤中最小路径值的小标 \n        for (i=0;i<n+2;i++)   //初始化标志数组，并把第一个点添加到点集中，即book[1] = 1 \n            book[i] = 0; \n        book[1] = 1; \n        for (i=1;i<=n;i++) \n            for (j=1;j<=n;j++) \n                d[i][j] = scanner.nextInt();   //读入二维矩阵，表示各个点的连接情况 \n        for (i=2;i<=n;i++) \n            f[i] = d[1][i];   //按照上文所说的第一步进行初始化 \n        System.out.println(\"运算过程：\"); \n        while (containsAllNodes(book, n)){ \n            min = 65535;  //每一步都要比较出最小值，所以记得在每一步的开始初始化一下最小值 \n            for (i=2;i<=n;i++) \n                if (book[i] == 0 && f[i] < min){   //当第i个点未被加入到点集中 && f[i]<min \n                    min = f[i]; \n                    min_pos = i; \n                } \n            book[min_pos] = 1;  //找出当前步骤中最小值的位置为min_pos，即第min_pos个点加入到点集中，book[min_pos] = 1 \n            for (i=1;i<=n;i++) \n                if (d[min_pos][i] != 65535)   //根据上文讲解，f[i] = min{ f[i], f[min_pos] + d[min_pos][i] }  这一步是最重要的，一定要理解。比如上面讲解的第二步中，D（3）= min{D（3）， D（2）+ d（2,3）}，类比一下 \n                    f[i] = f[i] < (f[min_pos] + d[min_pos][i]) ? f[i] : (f[min_pos] + d[min_pos][i]);  \n            for (i=1;i<=n;i++){ \n                System.out.print(f[i] + \" \");  //打印本次运算结果 \n            } \n            System.out.println(); \n        }\n        System.out.println(\"最短路径： \" + f[n]);  //整个过程全部结束了，打印出第1个点到第n个点的最短路径 \n    }\n    //判断是否所有点都被加入到点集中了 \n    private static boolean containsAllNodes(int[] book, int n) { \n        for (int i=1;i<=n;i++){ \n            if (book[i] == 0) \n                return true; \n        } \n        return false; \n    } \n}\n \n```\n\n总结：如果可以熟练的手工算出那张动态表的话，就可以很好的理解迪杰斯特拉算法了。迪杰斯特拉本质上是一种动态规划，每次只能求出一个点到任意一个点的最短距离，而不是任意一个点到任意一个点的最短距离；同时又体现了贪心策略的思想，当一个新的点被加入到点集中时，下一步只需要更新与其直接相连（相邻）的点即可，而不是需要更新所有的点。至于使用什么语言来实现就都无所谓啦。还有如果需要记录最短路径所经过的节点，再增加相应数组编程实现即可。","source":"_posts/编程实现路由算法--迪杰斯特拉算法.markdown","raw":"---\nlayout: post\ntitle: \"编程实现路由算法--迪杰斯特拉算法\"\ndate: 2014-11-27 15:20:33 +0800\ncomments: true\ntags: [Java, 路由算法, 迪杰斯特拉]\n---\n\n路由算法有很多，本篇采用迪杰斯特拉最短路径法实现简单的路由算法。可能很多人一看到这个就会想到数据结构了，想到数据结构中必须要建立图的结构就很头疼，今天这种写法可以先不采用数据结构书上的写法，也可以实现相同的功能，毕竟，咱们的重点是要学习使用迪杰斯特拉算法，而不是构建图结构。\n\n<!--more-->\n\n首先先来说一下迪杰斯特拉算法，从大概念上来说，该方法属于一种贪心算法，即当加进一个点后，算其相邻所有点的最短路径。详细过程如下：\n\n如下图，要计算其中 点1 到其余各点的最短路径\n\n![image](http://img.blog.csdn.net/20141127161359885)\n\n总的计算过程见下表\n\n![image](http://img.blog.csdn.net/20141127161400447)\n\n表中红颜色代表当前行未加入到点集中的最小值，蓝颜色代表和上一个新加入点集中的点相邻的点，可能这样说还不是很清楚，就看下面的具体过程了。\n\n第一步：初始化，把和 点1 相连的所有点的D（i）初始化，从图中可以看出，1和2、4、5相连，所以D（2）=10，D（4）=30，D（5）=100，点1和点3不直接相连，所以D（3）=65535，代表无穷大（在java里，可以用Integer.MAX_VALUE来表示无穷大）。由于现在点集中只有点1，所以找出刚才步骤1那行中D（i）最小的点，为点2（图中红色标明），将其加入到点集中。\n\n第二步：此时点集中新加入了点2，则以点2为出发点，从图中看到只有点3与其相连，所以这一步中只需要更新D（3）即可，D（3）= min{D（3）， D（2）+ d（2,3）}，即D（3）= min{65535， 10+ 50} = 60，更新D（3）=60，其余点不变。这行更新完毕，发现未加入到点集中的D（4）最小，所以将点4加入到点集中。\n\n第三步： 此时点集中新加入了点4，则以点4为出发点，从图中看到点3和点5与其相连，所以这一步需要更新D（3）和D（5）的值，D（3）= min{D（3）， D（4）+ d（4,3）} ，即D（3） = min{60, 30+20} = 50；D（5） = min{D（5）， D（4）+ d（4,5）} = min {100， 30 + 60} = 90。此时这一行其他数据不用变，此行更新完毕，找出未加入到点集中的 点3、点5 中的最小值，应该是点3，加入到点集中。\n\n第四步，此时点集中新加入了点3，则以点3为出发点，发现点5与其相连，只需要更新D（5）即可。D（5） = min{D（5）， D（3）+ d（3,5）} = min {90， 50 + 10} = 60，此时这行更新完毕，只有最后一个 点5 未加入到点集中了，所以将其加入。\n\n第五步，此时点集中新加入了点5，则以点5为出发点，发现根本没有点与其相连，甚好，此行就不用再更新了。\n\n第六步，机智的我发现所有点都被包含在了点集中，所以本次迪杰斯特拉算法就到此结束了。\n\n剩下的就是代码实现了。\n\n用一个二维数组d[i][j]来存从第i个点到第j个点的路径权重，其中65535为无穷大； 用一个一维数组f[i]才表示从第1个节点到第i个节点的最短路径。\n\n```\n/* \n*周梧桐   12283026\n*实验四 编程实现路由算法 \n*/ \npublic class Dijkstra_Router { \n    public static void main(String[] args) throws IOException { \n        Scanner scanner = new Scanner(System.in); \n        int i, j; \n        int n = scanner.nextInt(); \n        //因为第0个单元我不用，所以就多开了两个空间 \n        int[][] d = new int [n+2][n+2];  //二维矩阵存储点之间的距离 \n        int []book = new int [n+2];    //标志数组，book[i]=0代表第i个点未在点集中，book[i]=1代表第i个点在点集中 \n        int []f = new int[n+2];  //f[i]表示从第1个节点到第i个节点的最短路径 \n        int min = 65535, min_pos = 0;   //最小值设置为65535，为了比较出最小值， min_pos表示当前步骤中最小路径值的小标 \n        for (i=0;i<n+2;i++)   //初始化标志数组，并把第一个点添加到点集中，即book[1] = 1 \n            book[i] = 0; \n        book[1] = 1; \n        for (i=1;i<=n;i++) \n            for (j=1;j<=n;j++) \n                d[i][j] = scanner.nextInt();   //读入二维矩阵，表示各个点的连接情况 \n        for (i=2;i<=n;i++) \n            f[i] = d[1][i];   //按照上文所说的第一步进行初始化 \n        System.out.println(\"运算过程：\"); \n        while (containsAllNodes(book, n)){ \n            min = 65535;  //每一步都要比较出最小值，所以记得在每一步的开始初始化一下最小值 \n            for (i=2;i<=n;i++) \n                if (book[i] == 0 && f[i] < min){   //当第i个点未被加入到点集中 && f[i]<min \n                    min = f[i]; \n                    min_pos = i; \n                } \n            book[min_pos] = 1;  //找出当前步骤中最小值的位置为min_pos，即第min_pos个点加入到点集中，book[min_pos] = 1 \n            for (i=1;i<=n;i++) \n                if (d[min_pos][i] != 65535)   //根据上文讲解，f[i] = min{ f[i], f[min_pos] + d[min_pos][i] }  这一步是最重要的，一定要理解。比如上面讲解的第二步中，D（3）= min{D（3）， D（2）+ d（2,3）}，类比一下 \n                    f[i] = f[i] < (f[min_pos] + d[min_pos][i]) ? f[i] : (f[min_pos] + d[min_pos][i]);  \n            for (i=1;i<=n;i++){ \n                System.out.print(f[i] + \" \");  //打印本次运算结果 \n            } \n            System.out.println(); \n        }\n        System.out.println(\"最短路径： \" + f[n]);  //整个过程全部结束了，打印出第1个点到第n个点的最短路径 \n    }\n    //判断是否所有点都被加入到点集中了 \n    private static boolean containsAllNodes(int[] book, int n) { \n        for (int i=1;i<=n;i++){ \n            if (book[i] == 0) \n                return true; \n        } \n        return false; \n    } \n}\n \n```\n\n总结：如果可以熟练的手工算出那张动态表的话，就可以很好的理解迪杰斯特拉算法了。迪杰斯特拉本质上是一种动态规划，每次只能求出一个点到任意一个点的最短距离，而不是任意一个点到任意一个点的最短距离；同时又体现了贪心策略的思想，当一个新的点被加入到点集中时，下一步只需要更新与其直接相连（相邻）的点即可，而不是需要更新所有的点。至于使用什么语言来实现就都无所谓啦。还有如果需要记录最短路径所经过的节点，再增加相应数组编程实现即可。","slug":"编程实现路由算法--迪杰斯特拉算法","published":1,"updated":"2017-09-04T06:52:05.000Z","photos":[],"link":"","_id":"cj75tmhv90004oa5x67yikmxb"},{"layout":"post","title":"编程实现可靠数据传输原理Go-Back-N","date":"2014-11-29T07:20:33.000Z","comments":1,"_content":"\n有一个计算机网络的实验，需要模拟GBN的过程，即在本地条件下模拟丢包重传机制。刚看到这个实验时有些不知所措，因为不知道怎样能实现丢包，在本地编程，即使是使用不可靠数据传输UDP的DatagramSocket，由于localhost到localhost走的是回环链路，也就是从客户机的应用层--传输层--网络层 到 服务器的网络层--传输层--应用层，这个肯定无法丢包，也用实验进行验证了（比如连续发送1万个DatagramPacket，发现每一个都被收到了）。\n\n那么问题来了，怎样才能丢包？\n\n<!--more-->\n\n通过前面的叙述，可知在链路上丢包是不可能的了，那我们可以从服务器端下手，也就是说，即使服务器收到了某个数据包，也不给客户机发ACK，那么到了客户机设置的定时器后，客户机自然就认为是丢包了。所以可以给服务器设置一个丢包概率，用Math.random()函数来实现，该函数返回一个从0到1之间的随机数，可用来设置“丢包”概率。如设置丢包概率为0.3：\n\n```\nif (Math.random()<=0.7){ \n    //接收成功，发ack; \n}else{\n    //呵呵，什么都不做\n}\n```\n\n“丢包”问题解决了，下面就是怎么发送数据包，用之前学过的TCP的Socket也行，用UDP的DatagramSocket也行，这个实验就采用UDP编程吧，所以，下一个问题就是，如何用UDP编程。\n\n同样也需要Socket（不理解Socket是什么的可以看前几篇文章），不过这次的是DatagramSocket，代表是UDP的数据报套接字。DatagramSocket要往外发送数据包，也就是DatagramPacket。举一个客户机可以向服务器发送数据并在服务器显示的例子。\n\n客户端代码如下：\n\n```\npublic class UDPClient { \n    public static void main(String[] args) throws Exception { \n        //创建UDP的socket \n        DatagramSocket socket = new DatagramSocket(); \n        //通过域名来获得服务器的IP地址 \n        InetAddress serverAddress = InetAddress.getByName(\"localhost\"); \n        String str = \"Hello Server, I am client\"; \n        //需要将发送的字符串转换成字节数组，才能在互联网中传输 \n        byte[] data = str.getBytes(); \n        //新建数据包，指明发送数据内容，发送的长度，服务器地址，服务器端口号 \n        DatagramPacket packet = new DatagramPacket(data, data.length, \n                serverAddress, 8899); \n        //使用socket发送数据包 \n        socket.send(packet); \n    } \n}\n```\n\n对应服务器端代码如下：\n\n```\npublic class UDPServer { \n    public static void main(String[] args) throws Exception { \n        //新建服务器端socket，并同时设置监听端口 \n        DatagramSocket socket = new DatagramSocket(8899); \n        while (true){ \n            byte[] data = new byte[1024]; \n            //新建数据包，会把后面收到的内容放到data字节数组里，最大长度为data.length \n            DatagramPacket packet = new DatagramPacket(data, data.length); \n            //此方法为阻塞方法（block method）,直到监听到数据包后才会往下执行，不然就一直等待，就像ServerSocket.accept()方法一样 \n            socket.receive(packet); \n            //执行到这里说明监听到了数据包，并把其中内容转换为字符串 \n            String result = new String(packet.getData()); \n            //打印 \n            System.out.println(\"receive result : \" + result); \n        } \n    } \n}\n```\n\n务必先运行服务器端，再运行客户端。运行结果如下：\n\n![image](http://img.blog.csdn.net/20141129165114704?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n若想服务器端给客户端发送数据，可同样操作。\n\n利用DatagramSocket发送DatagramPacket的问题解决了，那么下一个问题，在GBN协议里面，客户端发送一个数据之后要设置定时器的，这个定时器怎么设置？\n\n在java里有两种方式来设置定时器，首先是第一种方法，使用Timer结合ActionListener即可。\n\n代码如下，其中值得注意的一点是Timer要导入java.swing这个包中的，而不是java.util这个包中的，否则不能正确运行。\n\n```\nimport java.awt.event.ActionEvent; \nimport java.awt.event.ActionListener;\nimport javax.swing.Timer;\npublic class TimerMain { \n    public static void main(String[] args) { \n        //设置定时器，第一个参数为延迟执行时间，单位是毫秒；第二个参数为到时间后执行的动作，类型为ActionListener \n        Timer timer = new Timer(3000, new DelayActionListener()); \n        //这个必须写，才可以使得timer生效 \n        timer.start(); \n        //为了不让程序结束，加个死循环，不然timer定时器还没到，主程序就结束了 \n        while (true){ \n        } \n    } \n}\n//自定义动作类实现ActionListener接口 \nclass DelayActionListener implements ActionListener{ \n    //此为回调方法，当时间到后自动执行actionPerformed方法 \n    @Override \n    public void actionPerformed(ActionEvent e) { \n        System.out.println(\"定时器时间到\"); \n    } \n}\n```\n\n运行结果如下：每隔3秒执行一次。如果需要取消定时器，使用timer.stop()方法即可。\n\n![image](http://img.blog.csdn.net/20141129165207500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n设置定时器的第二种方法是使用Timer结合TimerTask，在android里很常用，其实本来就是java的东西，代码如下：\n\n```\nimport java.util.Timer; \nimport java.util.TimerTask;\npublic class TimerTaskMain { \n    public static void main(String[] args) { \n        //使用TimerTask \n        TimerTask timerTask = new TimerTask() { \n            @Override \n            public void run() { \n                System.out.println(\"timerTask定时器时间到\"); \n            } \n        }; \n        Timer timer = new Timer(); \n        //第一个参数为要执行的目标，第二个参数为第一次执行延迟的时间，第三个参数为循环执行的时间间隔，单位都是毫秒 \n        timer.schedule(timerTask, 3000, 3000); \n    } \n}\n```\n\n运行结果如下：每隔3秒执行一次。如果需要取消定时器，使用timerTask.cancel()方法即可。\n\n![image](http://img.blog.csdn.net/20141129165146918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n有了如上这些东西，再结合GBN的原理和自己控制的逻辑操作，写GBN就应该可以实现了，就不贴完整代码了，自己实现印象更深刻些。","source":"_posts/编程实现可靠数据传输原理 Go-Back-N.markdown","raw":"---\nlayout: post\ntitle: \"编程实现可靠数据传输原理Go-Back-N\"\ndate: 2014-11-29 15:20:33 +0800\ncomments: true\ntags: [Java, GBN]\n---\n\n有一个计算机网络的实验，需要模拟GBN的过程，即在本地条件下模拟丢包重传机制。刚看到这个实验时有些不知所措，因为不知道怎样能实现丢包，在本地编程，即使是使用不可靠数据传输UDP的DatagramSocket，由于localhost到localhost走的是回环链路，也就是从客户机的应用层--传输层--网络层 到 服务器的网络层--传输层--应用层，这个肯定无法丢包，也用实验进行验证了（比如连续发送1万个DatagramPacket，发现每一个都被收到了）。\n\n那么问题来了，怎样才能丢包？\n\n<!--more-->\n\n通过前面的叙述，可知在链路上丢包是不可能的了，那我们可以从服务器端下手，也就是说，即使服务器收到了某个数据包，也不给客户机发ACK，那么到了客户机设置的定时器后，客户机自然就认为是丢包了。所以可以给服务器设置一个丢包概率，用Math.random()函数来实现，该函数返回一个从0到1之间的随机数，可用来设置“丢包”概率。如设置丢包概率为0.3：\n\n```\nif (Math.random()<=0.7){ \n    //接收成功，发ack; \n}else{\n    //呵呵，什么都不做\n}\n```\n\n“丢包”问题解决了，下面就是怎么发送数据包，用之前学过的TCP的Socket也行，用UDP的DatagramSocket也行，这个实验就采用UDP编程吧，所以，下一个问题就是，如何用UDP编程。\n\n同样也需要Socket（不理解Socket是什么的可以看前几篇文章），不过这次的是DatagramSocket，代表是UDP的数据报套接字。DatagramSocket要往外发送数据包，也就是DatagramPacket。举一个客户机可以向服务器发送数据并在服务器显示的例子。\n\n客户端代码如下：\n\n```\npublic class UDPClient { \n    public static void main(String[] args) throws Exception { \n        //创建UDP的socket \n        DatagramSocket socket = new DatagramSocket(); \n        //通过域名来获得服务器的IP地址 \n        InetAddress serverAddress = InetAddress.getByName(\"localhost\"); \n        String str = \"Hello Server, I am client\"; \n        //需要将发送的字符串转换成字节数组，才能在互联网中传输 \n        byte[] data = str.getBytes(); \n        //新建数据包，指明发送数据内容，发送的长度，服务器地址，服务器端口号 \n        DatagramPacket packet = new DatagramPacket(data, data.length, \n                serverAddress, 8899); \n        //使用socket发送数据包 \n        socket.send(packet); \n    } \n}\n```\n\n对应服务器端代码如下：\n\n```\npublic class UDPServer { \n    public static void main(String[] args) throws Exception { \n        //新建服务器端socket，并同时设置监听端口 \n        DatagramSocket socket = new DatagramSocket(8899); \n        while (true){ \n            byte[] data = new byte[1024]; \n            //新建数据包，会把后面收到的内容放到data字节数组里，最大长度为data.length \n            DatagramPacket packet = new DatagramPacket(data, data.length); \n            //此方法为阻塞方法（block method）,直到监听到数据包后才会往下执行，不然就一直等待，就像ServerSocket.accept()方法一样 \n            socket.receive(packet); \n            //执行到这里说明监听到了数据包，并把其中内容转换为字符串 \n            String result = new String(packet.getData()); \n            //打印 \n            System.out.println(\"receive result : \" + result); \n        } \n    } \n}\n```\n\n务必先运行服务器端，再运行客户端。运行结果如下：\n\n![image](http://img.blog.csdn.net/20141129165114704?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n若想服务器端给客户端发送数据，可同样操作。\n\n利用DatagramSocket发送DatagramPacket的问题解决了，那么下一个问题，在GBN协议里面，客户端发送一个数据之后要设置定时器的，这个定时器怎么设置？\n\n在java里有两种方式来设置定时器，首先是第一种方法，使用Timer结合ActionListener即可。\n\n代码如下，其中值得注意的一点是Timer要导入java.swing这个包中的，而不是java.util这个包中的，否则不能正确运行。\n\n```\nimport java.awt.event.ActionEvent; \nimport java.awt.event.ActionListener;\nimport javax.swing.Timer;\npublic class TimerMain { \n    public static void main(String[] args) { \n        //设置定时器，第一个参数为延迟执行时间，单位是毫秒；第二个参数为到时间后执行的动作，类型为ActionListener \n        Timer timer = new Timer(3000, new DelayActionListener()); \n        //这个必须写，才可以使得timer生效 \n        timer.start(); \n        //为了不让程序结束，加个死循环，不然timer定时器还没到，主程序就结束了 \n        while (true){ \n        } \n    } \n}\n//自定义动作类实现ActionListener接口 \nclass DelayActionListener implements ActionListener{ \n    //此为回调方法，当时间到后自动执行actionPerformed方法 \n    @Override \n    public void actionPerformed(ActionEvent e) { \n        System.out.println(\"定时器时间到\"); \n    } \n}\n```\n\n运行结果如下：每隔3秒执行一次。如果需要取消定时器，使用timer.stop()方法即可。\n\n![image](http://img.blog.csdn.net/20141129165207500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n设置定时器的第二种方法是使用Timer结合TimerTask，在android里很常用，其实本来就是java的东西，代码如下：\n\n```\nimport java.util.Timer; \nimport java.util.TimerTask;\npublic class TimerTaskMain { \n    public static void main(String[] args) { \n        //使用TimerTask \n        TimerTask timerTask = new TimerTask() { \n            @Override \n            public void run() { \n                System.out.println(\"timerTask定时器时间到\"); \n            } \n        }; \n        Timer timer = new Timer(); \n        //第一个参数为要执行的目标，第二个参数为第一次执行延迟的时间，第三个参数为循环执行的时间间隔，单位都是毫秒 \n        timer.schedule(timerTask, 3000, 3000); \n    } \n}\n```\n\n运行结果如下：每隔3秒执行一次。如果需要取消定时器，使用timerTask.cancel()方法即可。\n\n![image](http://img.blog.csdn.net/20141129165146918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n有了如上这些东西，再结合GBN的原理和自己控制的逻辑操作，写GBN就应该可以实现了，就不贴完整代码了，自己实现印象更深刻些。","slug":"编程实现可靠数据传输原理 Go-Back-N","published":1,"updated":"2017-09-04T06:51:23.000Z","photos":[],"link":"","_id":"cj75tmhvc0008oa5x64p98y38"},{"title":"算法之数组","date":"2015-04-18T14:18:44.000Z","_content":"\n数组的常见算法题，记录一下，以备忘。\n\n<!--more-->\n\n1、整型数组的逆置算法\n\n2、旋转数组\n   For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]。\n```\n\treverse(array, 0, n-k-1); // 反转前一半\n\treverse(array, n-k, n-1); // 反转后一半\n\treverse(array, 0, n-1);   // 反转整个数组\t\n```\n\n3、排序数组中和为 s 的两个数字\n   头尾两个指针相加，根据和的大小前后移动。也可以只用一个指针，在该指针后面的数组用二分查找看有没有满足要求的数『 mid = (low + high) >>> 1 』。\n\n4、和为 s 的连续正整数序列\n   两个指针，一个从1开始，一个从2开始，计算 start 指针到 end 指针的 sum，根据 sum 比较并移动指针。\n\n5、删除排序数组中的重复元素\n   借助 ArrayList；使用 ArrayCopy；使用临时变量","source":"_posts/算法之数组.markdown","raw":"title: 算法之数组\ndate: 2015-04-18 22:18:44\ntags: 算法\n---\n\n数组的常见算法题，记录一下，以备忘。\n\n<!--more-->\n\n1、整型数组的逆置算法\n\n2、旋转数组\n   For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]。\n```\n\treverse(array, 0, n-k-1); // 反转前一半\n\treverse(array, n-k, n-1); // 反转后一半\n\treverse(array, 0, n-1);   // 反转整个数组\t\n```\n\n3、排序数组中和为 s 的两个数字\n   头尾两个指针相加，根据和的大小前后移动。也可以只用一个指针，在该指针后面的数组用二分查找看有没有满足要求的数『 mid = (low + high) >>> 1 』。\n\n4、和为 s 的连续正整数序列\n   两个指针，一个从1开始，一个从2开始，计算 start 指针到 end 指针的 sum，根据 sum 比较并移动指针。\n\n5、删除排序数组中的重复元素\n   借助 ArrayList；使用 ArrayCopy；使用临时变量","slug":"算法之数组","published":1,"updated":"2017-09-04T06:49:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj75tmhvf000boa5xx660g896"},{"title":"数据结构 - 知识导图","date":"2017-02-18T14:18:44.000Z","_content":"\n数据结构知识导图\n\n<!--more-->\n\n# 数据结构\n\n![数据结构](http://7xivx9.com1.z0.glb.clouddn.com/summary数据结构.png)","source":"_posts/数据结构-导图.markdown","raw":"title: 数据结构 - 知识导图\ndate: 2017-02-18 22:18:44\ntags: 数据结构\n---\n\n数据结构知识导图\n\n<!--more-->\n\n# 数据结构\n\n![数据结构](http://7xivx9.com1.z0.glb.clouddn.com/summary数据结构.png)","slug":"数据结构-导图","published":1,"updated":"2017-09-04T07:23:49.000Z","_id":"cj75tmhvi000doa5xxb3celkh","comments":1,"layout":"post","photos":[],"link":""},{"title":"排序查找算法总结","date":"2015-04-18T14:18:44.000Z","_content":"\n总结下常见的各种排序算法，包括改进的冒泡排序、直接插入、快排、堆排等。\n\n<!--more-->\n\n# 普通冒泡排序\n\n```\nvoid bubbleSort(int data[], int n) {\n\tint i, j;\n\tfor ( i=0; i<n-1; i++ )\n\t\tfor ( j=n-1; j>i; j-- )\n\t\t\tswap(data, i, j);\n}\n```\n\n优化后的冒泡排序\n```\nvoid bubbleSort(int data[], int n) {\n\tint i, j;\n\tbool flag = true;\n\tfor ( i=0; i<n-1 && flag; i++) {\n\t\tflag = false;\n\t\tfor ( j=n-1; j>i; j--)\n\t\t\tif (needSwap) {\n\t\t\t\tswap(data, i, j);\n\t\t\t\tflag = true;\n\t\t\t}\n\t}\n}\n```\n\n# 快排\n```\nvoid QSort(int data[], int low, int high) {\n\tint pivot;\n\tif (low < high) {\n\t\tpivot = Partition(data, low, high);\n\t\tQSort(data, low, pivot-1);\n\t\tQSort(data, pivot+1, high);\n\t}\n}\n\nint Partition(int data[], int low, int high) {\n\tint pivotKey = data[low];\n\twhile (low < high) {\n\t\twhile (low < high && data[high] >= pivotKey)\n\t\t\thigh--;\n\t\tswap(data, low, high);\n\n\t\twhile (low <high && data[low] <= pivotKey)\n\t\t\tlow++;\n\t\tswap(data, low, high);\n\t}\n\treturn low;\n}\n```\n\n# 二分查找\n\n```\nint binarySearch(int data[], int n, int key) {\n\tint low = 0, high = n-1, mid;\n\t\n\twhile ( low <= high ) {\n\t\tmid = (low + high) >>> 1;\n\t\tif ( data[mid] > key ) \n\t\t\thigh = mid - 1;\n\t\telse if ( data[mid] < key )\n\t\t\tlow = mid + 1;\n\t\telse if ( data[mid] == key )\n\t\t\treturn mid;\n\t}\n\n\treturn -1;\n}\n```\n\n# 二叉排序树查找\n\n```\nclass BiTNode<T> {\n\tT data;\n\tBiTNode left, right;\n}\n\nBiTree search(BiTree root, int key) {\n\tif (root == null) \n\t\treturn null;\n\tif (key < root.data)\n\t\treturn search(root.left, key);\n\tif (key > root.data)\n\t\treturn search(root.right, key);\n\treturn root;\n}\n```\n\n# 散列表\n```\nvoid insertHash(int data[], int key, int n) {\n\tint addr = indexFor(key);\n\twhile (data[addr] != NULL_KEY)\n\t\taddr = (addr + 1) % n;\n\tdata[addr] = key;\n}\n\nint searchHash(int data[], int key, int n) {\n\taddr = indexFor(key);\n\twhile (data[addr] != key) {\n\t\taddr = (addr + 1) % n;\n\t\tif (data[addr] == NULL_KEY || addr = indexFor(key))\n\t\t\treturn -1;\n\t}\n\treturn addr;\n}\n```\n\n- 排序算法总结\n\n| 排序法 | 平均 | 最差 | 辅助 | 是否稳定 |\n|:-----:|:----:|:---:|:----:|:------:|\n| 冒泡 | O(n\\*n) | O(n\\*n) | O(1) | 稳定 |\n| 快排 | O(n\\*logn) | O(n\\*n) | O(logn)-O(n) | 不稳定 |\n| 选择 | O(n\\*n) | O(n\\*n) | O(1) | 稳定 |\n| 插入 | O(n\\*n) | O(n\\*n) | O(1) | 稳定 |\n| 堆排 | O(n\\*logn) | O(n\\*logn) | O(1) | 不稳定 |\n| 希尔 |  |  | O(1) | 不稳定 |\n\n![sort](http://7xivx9.com1.z0.glb.clouddn.com/sort.png)","source":"_posts/排序算法总结.markdown","raw":"title: 排序查找算法总结\ndate: 2015-04-18 22:18:44\ntags: 数据结构与算法\n---\n\n总结下常见的各种排序算法，包括改进的冒泡排序、直接插入、快排、堆排等。\n\n<!--more-->\n\n# 普通冒泡排序\n\n```\nvoid bubbleSort(int data[], int n) {\n\tint i, j;\n\tfor ( i=0; i<n-1; i++ )\n\t\tfor ( j=n-1; j>i; j-- )\n\t\t\tswap(data, i, j);\n}\n```\n\n优化后的冒泡排序\n```\nvoid bubbleSort(int data[], int n) {\n\tint i, j;\n\tbool flag = true;\n\tfor ( i=0; i<n-1 && flag; i++) {\n\t\tflag = false;\n\t\tfor ( j=n-1; j>i; j--)\n\t\t\tif (needSwap) {\n\t\t\t\tswap(data, i, j);\n\t\t\t\tflag = true;\n\t\t\t}\n\t}\n}\n```\n\n# 快排\n```\nvoid QSort(int data[], int low, int high) {\n\tint pivot;\n\tif (low < high) {\n\t\tpivot = Partition(data, low, high);\n\t\tQSort(data, low, pivot-1);\n\t\tQSort(data, pivot+1, high);\n\t}\n}\n\nint Partition(int data[], int low, int high) {\n\tint pivotKey = data[low];\n\twhile (low < high) {\n\t\twhile (low < high && data[high] >= pivotKey)\n\t\t\thigh--;\n\t\tswap(data, low, high);\n\n\t\twhile (low <high && data[low] <= pivotKey)\n\t\t\tlow++;\n\t\tswap(data, low, high);\n\t}\n\treturn low;\n}\n```\n\n# 二分查找\n\n```\nint binarySearch(int data[], int n, int key) {\n\tint low = 0, high = n-1, mid;\n\t\n\twhile ( low <= high ) {\n\t\tmid = (low + high) >>> 1;\n\t\tif ( data[mid] > key ) \n\t\t\thigh = mid - 1;\n\t\telse if ( data[mid] < key )\n\t\t\tlow = mid + 1;\n\t\telse if ( data[mid] == key )\n\t\t\treturn mid;\n\t}\n\n\treturn -1;\n}\n```\n\n# 二叉排序树查找\n\n```\nclass BiTNode<T> {\n\tT data;\n\tBiTNode left, right;\n}\n\nBiTree search(BiTree root, int key) {\n\tif (root == null) \n\t\treturn null;\n\tif (key < root.data)\n\t\treturn search(root.left, key);\n\tif (key > root.data)\n\t\treturn search(root.right, key);\n\treturn root;\n}\n```\n\n# 散列表\n```\nvoid insertHash(int data[], int key, int n) {\n\tint addr = indexFor(key);\n\twhile (data[addr] != NULL_KEY)\n\t\taddr = (addr + 1) % n;\n\tdata[addr] = key;\n}\n\nint searchHash(int data[], int key, int n) {\n\taddr = indexFor(key);\n\twhile (data[addr] != key) {\n\t\taddr = (addr + 1) % n;\n\t\tif (data[addr] == NULL_KEY || addr = indexFor(key))\n\t\t\treturn -1;\n\t}\n\treturn addr;\n}\n```\n\n- 排序算法总结\n\n| 排序法 | 平均 | 最差 | 辅助 | 是否稳定 |\n|:-----:|:----:|:---:|:----:|:------:|\n| 冒泡 | O(n\\*n) | O(n\\*n) | O(1) | 稳定 |\n| 快排 | O(n\\*logn) | O(n\\*n) | O(logn)-O(n) | 不稳定 |\n| 选择 | O(n\\*n) | O(n\\*n) | O(1) | 稳定 |\n| 插入 | O(n\\*n) | O(n\\*n) | O(1) | 稳定 |\n| 堆排 | O(n\\*logn) | O(n\\*logn) | O(1) | 不稳定 |\n| 希尔 |  |  | O(1) | 不稳定 |\n\n![sort](http://7xivx9.com1.z0.glb.clouddn.com/sort.png)","slug":"排序算法总结","published":1,"updated":"2017-10-20T13:18:51.000Z","_id":"cj75tmhvk000foa5xoos2zvfe","comments":1,"layout":"post","photos":[],"link":""},{"layout":"post","title":"在 Mac 下安装 mysql for python","date":"2015-04-10T11:49:33.000Z","comments":1,"_content":"\n在 Mac 中使用 XAMPP 环境下，如何来为 python 安装 mysql\n\n<!--more-->\n\n停下手头的，写点东西。\n\n关于如何能在 Mac 下为 python 安装 mysql，真是折腾了一会。之前在 windows 下装过，很顺利，这次到 Mac 下居然这么坎坷了。特来记录一下过程，共享学习。\n\n我的环境：Mac Yosetime 10.10.2 + python 2.7 + XAMPP\n\n凡是在搜索“python mysqldb 安装 mac”等类关键字时，得到的教程基本都是一致的，教程如下，我开始也是照着这个来的但是不成功，原因是我用的是 XAMPP（下文具体讲）。\n\n在下面的网址下载mysqldb模块：\n```\nhttp://sourceforge.net/projects/mysql-python/\n```\n\n在mac os x直接双击解压,命令行进入解压后的目录， 执行\n```\npython setup.py build\n```\n\n如果有\n```\nsh: mysql_config: command not found\n```\n\n提示，我们需要编辑下mysql的路径，打开setup_posix.py\n\n找到:\n```\nmysql_config.path = \"mysql_config\"\n```\n\n改为：\n```\nmysql_config.path = \"/usr/local/mysql/bin/mysql_config\"\n```\n\n再执行一次 build：\n```\npython setup.py build\n```\n\nbuild 没问题了，然后执行：\n```\nsudo python setup.py install\n```\n\n安装成功后，在命令行输入 python 进入 python 环境，如果报下面的错误：\n```\nImportError: dlopen(/Library/Python/2.7/site-packages/MySQL_python-1.2.4b4-py2.7-macosx-10.8-intel.egg/_mysql.so, 2): Library not loaded: libmysqlclient.18.dylib\n  Referenced from: /Library/Python/2.7/site-packages/MySQL_python-1.2.4b4-py2.7-macosx-10.8-intel.egg/_mysql.so\n  Reason: image not found\n```\n\n解决方法，建立一个软链就可以了\n```\nsudo ln -s /usr/local/mysql/lib/libmysqlclient.18.dylib /usr/lib/libmysqlclient.18.dylib\n```\n\nOver~如果你的 mysql 是手动安装的话，也许上面的教程就没有问题了，但关键是在于，我在 `python setup.py build` 的时候总是告诉我 mysql_config 命令找不到。根本原因是我这里的 mysql 是在 xampp 中的，所以 `mysql_config` 命令是在 `/Applications/XAMPP/xamppfiles/bin/mysql_config` 这里的，找到原因了，再打开 setup_posix.py\n\n找到:\n```\nmysql_config.path = \"mysql_config\"\n```\n\n这次改为：\n```\nmysql_config.path = \"/Applications/XAMPP/xamppfiles/bin/mysql_config\"\n```\n\n之后再build：\n```\npython setup.py build\n```\n\n发现就成功了，并且没有报任何错误，另外还有同样的一点，在设置软链接时，也需要做相同的修改：\n```\nsudo ln -s /Applications/XAMPP/xamppfiles/bin/libmysqlclient.18.dylib /usr/lib/libmysqlclient.18.dylib\n```\n\n其余部分按照刚才教程之后的步骤操作就可以了。\n\n总结：本次为 python 安装 mysql 屡屡失败的根本原因是在于自己过于相信网上的教程了，并不是说教程不对，而是说自己太不过脑子了，直接照抄并不思考为什么，刚才的错误只要稍微思考一下就能知道错误原因在哪里了，也不用浪费那么多时间了。\n\n好了，继续了。","source":"_posts/在 Mac 下安装 mysql for python.markdown","raw":"---\nlayout: post\ntitle: \"在 Mac 下安装 mysql for python\"\ndate: 2015-04-10 19:49:33 +0800\ncomments: true\ntags: [Python, Mysql]\n---\n\n在 Mac 中使用 XAMPP 环境下，如何来为 python 安装 mysql\n\n<!--more-->\n\n停下手头的，写点东西。\n\n关于如何能在 Mac 下为 python 安装 mysql，真是折腾了一会。之前在 windows 下装过，很顺利，这次到 Mac 下居然这么坎坷了。特来记录一下过程，共享学习。\n\n我的环境：Mac Yosetime 10.10.2 + python 2.7 + XAMPP\n\n凡是在搜索“python mysqldb 安装 mac”等类关键字时，得到的教程基本都是一致的，教程如下，我开始也是照着这个来的但是不成功，原因是我用的是 XAMPP（下文具体讲）。\n\n在下面的网址下载mysqldb模块：\n```\nhttp://sourceforge.net/projects/mysql-python/\n```\n\n在mac os x直接双击解压,命令行进入解压后的目录， 执行\n```\npython setup.py build\n```\n\n如果有\n```\nsh: mysql_config: command not found\n```\n\n提示，我们需要编辑下mysql的路径，打开setup_posix.py\n\n找到:\n```\nmysql_config.path = \"mysql_config\"\n```\n\n改为：\n```\nmysql_config.path = \"/usr/local/mysql/bin/mysql_config\"\n```\n\n再执行一次 build：\n```\npython setup.py build\n```\n\nbuild 没问题了，然后执行：\n```\nsudo python setup.py install\n```\n\n安装成功后，在命令行输入 python 进入 python 环境，如果报下面的错误：\n```\nImportError: dlopen(/Library/Python/2.7/site-packages/MySQL_python-1.2.4b4-py2.7-macosx-10.8-intel.egg/_mysql.so, 2): Library not loaded: libmysqlclient.18.dylib\n  Referenced from: /Library/Python/2.7/site-packages/MySQL_python-1.2.4b4-py2.7-macosx-10.8-intel.egg/_mysql.so\n  Reason: image not found\n```\n\n解决方法，建立一个软链就可以了\n```\nsudo ln -s /usr/local/mysql/lib/libmysqlclient.18.dylib /usr/lib/libmysqlclient.18.dylib\n```\n\nOver~如果你的 mysql 是手动安装的话，也许上面的教程就没有问题了，但关键是在于，我在 `python setup.py build` 的时候总是告诉我 mysql_config 命令找不到。根本原因是我这里的 mysql 是在 xampp 中的，所以 `mysql_config` 命令是在 `/Applications/XAMPP/xamppfiles/bin/mysql_config` 这里的，找到原因了，再打开 setup_posix.py\n\n找到:\n```\nmysql_config.path = \"mysql_config\"\n```\n\n这次改为：\n```\nmysql_config.path = \"/Applications/XAMPP/xamppfiles/bin/mysql_config\"\n```\n\n之后再build：\n```\npython setup.py build\n```\n\n发现就成功了，并且没有报任何错误，另外还有同样的一点，在设置软链接时，也需要做相同的修改：\n```\nsudo ln -s /Applications/XAMPP/xamppfiles/bin/libmysqlclient.18.dylib /usr/lib/libmysqlclient.18.dylib\n```\n\n其余部分按照刚才教程之后的步骤操作就可以了。\n\n总结：本次为 python 安装 mysql 屡屡失败的根本原因是在于自己过于相信网上的教程了，并不是说教程不对，而是说自己太不过脑子了，直接照抄并不思考为什么，刚才的错误只要稍微思考一下就能知道错误原因在哪里了，也不用浪费那么多时间了。\n\n好了，继续了。","slug":"在 Mac 下安装 mysql for python","published":1,"updated":"2017-09-04T06:50:00.000Z","photos":[],"link":"","_id":"cj75tmhvm000hoa5xi6ep8fnr"},{"title":"图总结","date":"2015-04-18T14:18:44.000Z","_content":"\n图的遍历。\n\n<!--more-->\n\n## 结构体定义\n\n```\nclass EdgeNode {\n\tint adjvex;\n\tEdgeNode next;\n}\n\nclass VertexNode {\n\tchar data;\n\tEdgeNode firstedge;\n};\n\nclass GraphAdjList {\n\tAdjList adjList;\n\tint numVertexes, numEdges;\n}\n```\n\n## 邻接表的深度优先递归算法\n\n```\nvoid dfs(GraphAdjList gl, int i) {\n\tvisited[i] = true;\n\tprint(gl.adjList[i].data);\n\tEdgeNode p = gl.adjList[i].firstedge;\n\n\twhile (p) {\n\t\tif ( !visited[p.adjvex] )\n\t\t\tDFS(gl, p.adjVex);\n\t\tp = p.next;\n\t}\n}\n\nvoid dfsTraverse(GraphAdjList gl) {\n\tfor (i=0;i<gl.numVertexes;i++)\n\t\tvisited[i] = false;\n\tfor (i=0;i<gl.numVertexes;i++)\n\t\tif (!visited[i])\n\t\t\tdfs(gl, i);\n}\n```","source":"_posts/图总结.markdown","raw":"title: 图总结\ndate: 2015-04-18 22:18:44\ntags: 数据结构与算法\n---\n\n图的遍历。\n\n<!--more-->\n\n## 结构体定义\n\n```\nclass EdgeNode {\n\tint adjvex;\n\tEdgeNode next;\n}\n\nclass VertexNode {\n\tchar data;\n\tEdgeNode firstedge;\n};\n\nclass GraphAdjList {\n\tAdjList adjList;\n\tint numVertexes, numEdges;\n}\n```\n\n## 邻接表的深度优先递归算法\n\n```\nvoid dfs(GraphAdjList gl, int i) {\n\tvisited[i] = true;\n\tprint(gl.adjList[i].data);\n\tEdgeNode p = gl.adjList[i].firstedge;\n\n\twhile (p) {\n\t\tif ( !visited[p.adjvex] )\n\t\t\tDFS(gl, p.adjVex);\n\t\tp = p.next;\n\t}\n}\n\nvoid dfsTraverse(GraphAdjList gl) {\n\tfor (i=0;i<gl.numVertexes;i++)\n\t\tvisited[i] = false;\n\tfor (i=0;i<gl.numVertexes;i++)\n\t\tif (!visited[i])\n\t\t\tdfs(gl, i);\n}\n```","slug":"图总结","published":1,"updated":"2017-10-20T13:22:43.000Z","_id":"cj75tmhvo000koa5x9gn9am0m","comments":1,"layout":"post","photos":[],"link":""},{"title":"单链表逆置","date":"2017-03-02T14:18:44.000Z","_content":"\n总结一下单链表的逆置算法，包括 `复制逆置` 和 `就地逆置`。\n\n<!--more-->\n\n# 复制逆置\n所谓复制逆置，就是再开一个同样的空间，用于存储新的单链表，空间复杂度为O(n)。具体做法：从原链表顺序取元素，采用头插法插入到新的空链表中，完成逆置。\n\n复制逆置没有什么难度，主要考的还是 `就地逆置`。\n\n# 就地逆置\n就地逆置要保证时间复杂度为O(n) && 无辅助空间。总的来说：设置一指针p总是指向第一个结点（即从头到尾都指向的是同一个`第一个`结点），每次都将p后面的结点用头插法移动到头结点后面，循环就好了。\n\n具体算法：\n\n```java\nclass LinkList<T> {\n\tT data;\n\tLinkList next;\n}\n\npublic void reverse(LinkList list) {\n\tLinkList p, q; //p总是指向开始就是第一个的结点, q = p->next\n\tif ( list == NULL )\n\t\treturn;\n\n\tp = list.next; //从下面也可以看出来，p的指针就不再变化了\n\n\twhile ( p.next != null ){\n\t\tq = p.next;\n\t\tp.next = q.next;\n\t\tq.next = list.next;\n\t\tlist.next = q;\n\t}\n}\n```\n\n参考文章 : [pianoid 博客](http://www.cnblogs.com/pianoid/archive/2011/05/03/reverse-a-singly-linked-list.html)","source":"_posts/单链表逆置.markdown","raw":"title: 单链表逆置\ndate: 2017-03-02 22:18:44\ntags: 数据结构与算法\n---\n\n总结一下单链表的逆置算法，包括 `复制逆置` 和 `就地逆置`。\n\n<!--more-->\n\n# 复制逆置\n所谓复制逆置，就是再开一个同样的空间，用于存储新的单链表，空间复杂度为O(n)。具体做法：从原链表顺序取元素，采用头插法插入到新的空链表中，完成逆置。\n\n复制逆置没有什么难度，主要考的还是 `就地逆置`。\n\n# 就地逆置\n就地逆置要保证时间复杂度为O(n) && 无辅助空间。总的来说：设置一指针p总是指向第一个结点（即从头到尾都指向的是同一个`第一个`结点），每次都将p后面的结点用头插法移动到头结点后面，循环就好了。\n\n具体算法：\n\n```java\nclass LinkList<T> {\n\tT data;\n\tLinkList next;\n}\n\npublic void reverse(LinkList list) {\n\tLinkList p, q; //p总是指向开始就是第一个的结点, q = p->next\n\tif ( list == NULL )\n\t\treturn;\n\n\tp = list.next; //从下面也可以看出来，p的指针就不再变化了\n\n\twhile ( p.next != null ){\n\t\tq = p.next;\n\t\tp.next = q.next;\n\t\tq.next = list.next;\n\t\tlist.next = q;\n\t}\n}\n```\n\n参考文章 : [pianoid 博客](http://www.cnblogs.com/pianoid/archive/2011/05/03/reverse-a-singly-linked-list.html)","slug":"单链表逆置","published":1,"updated":"2017-10-20T13:14:11.000Z","_id":"cj75tmhvp000moa5xqizlyl5l","comments":1,"layout":"post","photos":[],"link":""},{"layout":"post","title":"【视频教程】典型 TCP 攻击实验","date":"2015-06-10T07:25:33.000Z","comments":1,"_content":"\n记录典型 TCP 攻击实验的原理及操作步骤。\n\n<!--more-->\n\n在本次实验中，启用了三个虚拟机，处于同一子网中。同时使用了 Wireshark 来进行网络抓包分析，使用 netwox 工具箱来进行攻击实验。\n\n1.ARP缓存中毒（ARP cache poisoning）\n\nARP 缓存是 ARP 协议的重要组成部分。ARP 协议运行的目标就是建立 MAC 地址和 IP 地址的映射，然后把这一映射关系保存在 ARP 缓存中，使得不必重复运行 ARP 协议。因为 ARP 缓存中的映射表并不是一直不变的，主机会定期发送 ARP 请求来更新它的 ARP 映射表，利用这个机制，攻击者可以伪造 ARP 应答帧使得主机错误的更新自己的 ARP 映射表，这个过程就是 ARP 缓存中毒。\n\n这样的后果即使要么使主机发送 MAC 帧到错误的 MAC 地址，导致数据被窃听；要么由于 MAC 地址不存在，导致数据发送不成功。\n\n关键 netwox 命令:\n\n`netwox 80 --eth \"00:00:00:00:00:00\" --ip \"192.168.224.134\"` 表示 发送 ARP 的响应包，Wireshark 抓包如下：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/tcp_01arp.png)\n\n具体过程演示：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/tcp_01ARP_cache_poisoning.mp4\" controls=\"controls\"></video>\n</div>\n\n2.SYN 泛洪攻击\n\nSYN 攻击是一种 DoS（Denial of Service）攻击，在这种攻击中黑客向被攻击者的 TCP 端口发送很多 SYN 请求，但是黑客并不是想完成三次握手协议，而是使用伪造的 IP 地址或者只进行三次握手协议中的第一次握手。因为 SYN 数据包用来打开一个 TCP 链接，所以受害者的机器会向伪造的地址发送一个 SYN/ACK 数据包作为回应，并等待预期的 ACK 响应。每个处于等待状态，半开的链接队列都讲进入空间有限的待处理队列。由于伪造的源地址实际上并不存在，所以将那些等待队列中的记录删除并完成建立 TCP 连接所需的 ACK 响应用于不会到来，相反每个半开的连接一定会超时，这将花费一段比较长的时间。\n\n只要攻击者使用伪造的 SYN 数据包继续泛洪受害者的系统，受害者的待处理队列将一直处于满员，这使得真正的 SYN 数据包几乎不可能到达系统并打开有效的 TCP 连接。\n\n关键 netwox 命令:\n\n`netwox 76 -i \"192.168.224.134\" -p \"23\"` 代表向目标主机的23号端口发送大量 TCP 连接请求，目标主机连接请求如图：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/tcp_03synflooding.png)\n\n具体过程演示：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/tcp_03SYN_Flooding_Attack.mp4\" controls=\"controls\"></video>\n</div>\n\n3.对 Telnet 的 TCP RST 攻击\n\nTCP RST 攻击可以终止两个被攻击主机之间的 TCP 连接。\n\nA和服务器B之间建立了 TCP 连接，此时C伪造了一个 TCP 包发给B，使B异常的断开了与A之间的 TCP 连接，就是 RST 攻击了。实际上从RST 标志位的功能已经可以看出这种攻击如何达到效果了。\n\n关键 netwox 命令:\n\n`netwox 78 -i \"192.168.224.138\"` 代表向目标主机发送 TCP RST 数据包，使其中断 telnet 连接：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/tcp_04tcprst.png)\n\n具体过程演示：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/tcp_04TCP_RST.mp4\" controls=\"controls\"></video>\n</div>\n\n最后，感谢 静姐 提供 [知道创宇研发技能表](http://blog.knownsec.com/Knownsec_RD_Checklist/v2.2.html)！","source":"_posts/典型tcp攻击实验.markdown","raw":"---\nlayout: post\ntitle: \"【视频教程】典型 TCP 攻击实验\"\ndate: 2015-06-10 15:25:33 +0800\ncomments: true\ntags: [TCP, netwox]\n---\n\n记录典型 TCP 攻击实验的原理及操作步骤。\n\n<!--more-->\n\n在本次实验中，启用了三个虚拟机，处于同一子网中。同时使用了 Wireshark 来进行网络抓包分析，使用 netwox 工具箱来进行攻击实验。\n\n1.ARP缓存中毒（ARP cache poisoning）\n\nARP 缓存是 ARP 协议的重要组成部分。ARP 协议运行的目标就是建立 MAC 地址和 IP 地址的映射，然后把这一映射关系保存在 ARP 缓存中，使得不必重复运行 ARP 协议。因为 ARP 缓存中的映射表并不是一直不变的，主机会定期发送 ARP 请求来更新它的 ARP 映射表，利用这个机制，攻击者可以伪造 ARP 应答帧使得主机错误的更新自己的 ARP 映射表，这个过程就是 ARP 缓存中毒。\n\n这样的后果即使要么使主机发送 MAC 帧到错误的 MAC 地址，导致数据被窃听；要么由于 MAC 地址不存在，导致数据发送不成功。\n\n关键 netwox 命令:\n\n`netwox 80 --eth \"00:00:00:00:00:00\" --ip \"192.168.224.134\"` 表示 发送 ARP 的响应包，Wireshark 抓包如下：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/tcp_01arp.png)\n\n具体过程演示：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/tcp_01ARP_cache_poisoning.mp4\" controls=\"controls\"></video>\n</div>\n\n2.SYN 泛洪攻击\n\nSYN 攻击是一种 DoS（Denial of Service）攻击，在这种攻击中黑客向被攻击者的 TCP 端口发送很多 SYN 请求，但是黑客并不是想完成三次握手协议，而是使用伪造的 IP 地址或者只进行三次握手协议中的第一次握手。因为 SYN 数据包用来打开一个 TCP 链接，所以受害者的机器会向伪造的地址发送一个 SYN/ACK 数据包作为回应，并等待预期的 ACK 响应。每个处于等待状态，半开的链接队列都讲进入空间有限的待处理队列。由于伪造的源地址实际上并不存在，所以将那些等待队列中的记录删除并完成建立 TCP 连接所需的 ACK 响应用于不会到来，相反每个半开的连接一定会超时，这将花费一段比较长的时间。\n\n只要攻击者使用伪造的 SYN 数据包继续泛洪受害者的系统，受害者的待处理队列将一直处于满员，这使得真正的 SYN 数据包几乎不可能到达系统并打开有效的 TCP 连接。\n\n关键 netwox 命令:\n\n`netwox 76 -i \"192.168.224.134\" -p \"23\"` 代表向目标主机的23号端口发送大量 TCP 连接请求，目标主机连接请求如图：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/tcp_03synflooding.png)\n\n具体过程演示：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/tcp_03SYN_Flooding_Attack.mp4\" controls=\"controls\"></video>\n</div>\n\n3.对 Telnet 的 TCP RST 攻击\n\nTCP RST 攻击可以终止两个被攻击主机之间的 TCP 连接。\n\nA和服务器B之间建立了 TCP 连接，此时C伪造了一个 TCP 包发给B，使B异常的断开了与A之间的 TCP 连接，就是 RST 攻击了。实际上从RST 标志位的功能已经可以看出这种攻击如何达到效果了。\n\n关键 netwox 命令:\n\n`netwox 78 -i \"192.168.224.138\"` 代表向目标主机发送 TCP RST 数据包，使其中断 telnet 连接：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/tcp_04tcprst.png)\n\n具体过程演示：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/tcp_04TCP_RST.mp4\" controls=\"controls\"></video>\n</div>\n\n最后，感谢 静姐 提供 [知道创宇研发技能表](http://blog.knownsec.com/Knownsec_RD_Checklist/v2.2.html)！","slug":"典型tcp攻击实验","published":1,"updated":"2017-09-04T06:48:31.000Z","photos":[],"link":"","_id":"cj75tmhvr000ooa5xeslpvxya"},{"layout":"post","title":"使用 Wireshark 抓包分析的思考","date":"2014-10-25T07:20:33.000Z","comments":1,"_content":"\n上一篇文章提到了一个问题，即为什么telnet登陆pop邮箱的时候用的是明文，至今不解，为了打消telnet会帮我进行加密传输的小疑问，所以就使用wireshark来看一下数据包的内容。\n\n<!--more-->\n\n依旧使用163邮箱作为实验。打开wireshark，让其抓取我本机网卡的数据包，开始抓包后，通过在cmd中 telnet pop.163.com 110 登陆163服务器，在wireshark里设置过滤规则:  tcp.port==110 (因为pop默认使用110号端口),我每在命令行里输入一个字符，（不用打回车），在wireshark里可以看到数据被封包后发出去了，这也印证了我上篇文章提到过的输入错了按空格是没用的，因为它已经发出去了！我测试输入 `user zhouwut7`,`pass zhouwut7`，可以明显看到telnet用明文把我输入的内容发送出去了，见下图：\n\n![image](http://img.blog.csdn.net/20141025175729755?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n好了，对于为什么pop使用明文，我还是不明白，若谁能明白，希望能帮我讲解一下。\n\n接下来，我又实验了自己学校的邮箱服务器，通过网页形式登陆，发现传输的依旧是明文，实验过程为：wireshark开始抓包，打开邮箱网页，正常登陆，在wireshark中寻找数据包并设置过滤规则，查看数据包。结果如下图：\n\n![image](http://img.blog.csdn.net/20141025175804153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![image](http://img.blog.csdn.net/20141025175821984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n紧接着，我又测试了foxmail邮件客户端软件，尝试用其登陆我的新浪邮箱，对其进行抓包分析。发现foxmail在往外发数据的时候居然也是明文，结果如下：\n\n![image](http://img.blog.csdn.net/20141025175838036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n我顿时就蒙了，是对邮箱服务器本来就可以明文传输，还是我现在实验的对象都对安全问题考虑不周呢？\n\n然后，我选择了新浪邮箱，这个应该还算是国内比较常用的邮箱之一了，如果它都是用明文传输的话，我真是疯了。\n\n所以，赶紧实验，方法如上一样，继续用wireshark，结果如下图所示：\n\n![image](http://img.blog.csdn.net/20141025175856304?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这时我发现，我在登陆新浪邮箱的时候，从我网卡里传输出去的数据包是经过`SSL`加密了的（Secure Socket Layer），`不是明文`。其实这才是我预想中的结果，我觉得像用户名密码这种东西在网络上传输必须加密,至少新浪邮箱给了我一点安慰。\n\nwireshark这个东西很强大，但是现在还抓不了局域网中的包，尤其是某些宿舍使用了360安全路由器后。。。","source":"_posts/使用 Wireshark 抓包分析的思考.markdown","raw":"---\nlayout: post\ntitle: \"使用 Wireshark 抓包分析的思考\"\ndate: 2014-10-25 15:20:33 +0800\ncomments: true\ntags: [Wireshark]\n---\n\n上一篇文章提到了一个问题，即为什么telnet登陆pop邮箱的时候用的是明文，至今不解，为了打消telnet会帮我进行加密传输的小疑问，所以就使用wireshark来看一下数据包的内容。\n\n<!--more-->\n\n依旧使用163邮箱作为实验。打开wireshark，让其抓取我本机网卡的数据包，开始抓包后，通过在cmd中 telnet pop.163.com 110 登陆163服务器，在wireshark里设置过滤规则:  tcp.port==110 (因为pop默认使用110号端口),我每在命令行里输入一个字符，（不用打回车），在wireshark里可以看到数据被封包后发出去了，这也印证了我上篇文章提到过的输入错了按空格是没用的，因为它已经发出去了！我测试输入 `user zhouwut7`,`pass zhouwut7`，可以明显看到telnet用明文把我输入的内容发送出去了，见下图：\n\n![image](http://img.blog.csdn.net/20141025175729755?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n好了，对于为什么pop使用明文，我还是不明白，若谁能明白，希望能帮我讲解一下。\n\n接下来，我又实验了自己学校的邮箱服务器，通过网页形式登陆，发现传输的依旧是明文，实验过程为：wireshark开始抓包，打开邮箱网页，正常登陆，在wireshark中寻找数据包并设置过滤规则，查看数据包。结果如下图：\n\n![image](http://img.blog.csdn.net/20141025175804153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n![image](http://img.blog.csdn.net/20141025175821984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n紧接着，我又测试了foxmail邮件客户端软件，尝试用其登陆我的新浪邮箱，对其进行抓包分析。发现foxmail在往外发数据的时候居然也是明文，结果如下：\n\n![image](http://img.blog.csdn.net/20141025175838036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n我顿时就蒙了，是对邮箱服务器本来就可以明文传输，还是我现在实验的对象都对安全问题考虑不周呢？\n\n然后，我选择了新浪邮箱，这个应该还算是国内比较常用的邮箱之一了，如果它都是用明文传输的话，我真是疯了。\n\n所以，赶紧实验，方法如上一样，继续用wireshark，结果如下图所示：\n\n![image](http://img.blog.csdn.net/20141025175856304?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaWNvZGV5b3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n这时我发现，我在登陆新浪邮箱的时候，从我网卡里传输出去的数据包是经过`SSL`加密了的（Secure Socket Layer），`不是明文`。其实这才是我预想中的结果，我觉得像用户名密码这种东西在网络上传输必须加密,至少新浪邮箱给了我一点安慰。\n\nwireshark这个东西很强大，但是现在还抓不了局域网中的包，尤其是某些宿舍使用了360安全路由器后。。。","slug":"使用 Wireshark 抓包分析的思考","published":1,"updated":"2017-09-04T06:53:06.000Z","photos":[],"link":"","_id":"cj75tmhvu000roa5xzaly64wv"},{"title":"二叉树算法总结","date":"2015-04-18T14:18:44.000Z","_content":"\n二叉树的相关算法，建立、遍历等。\n\n<!--more-->\n\n## 二叉树类结构定义\n\n```\nclass TreeNode<T> {\n\tT data;\n\tTreeNode left, right;\n}\n```\n\n## 递归遍历（前序）\n\n```\nvoid preOrderTraverse(TreeNode root) {\n\tif (root == null)\n\t\treturn;\n\tprint(root.data);\n\tpreOrderTraverse(root.left);\n\tpreOrderTraverse(root.right);\n}\n```\n\n## 非递归遍历（前序）\n\n```\nvoid preOrderTraverse(TreeNode root) {\n\tif (root == null)\n\t\treturn;\n\t\n\tStack<TreeNode> stack = new Stack<>();\n\tTreeNode cur = root;\n\n\twhile (cur != null || !stack.empty()) {\n\n\t\twhile (cur != null) {\n\t\t\tprint(cur.data);\n\t\t\tstack.push(cur);\n\t\t\tcur = cur.left;\n\t\t}\n\n\t\tif (!stack.empty()) {\n\t\t\tcur = stack.pop();\n\t\t\tcur = cur.right;\n\t\t}\n\n\t}\t\n}\n```\n\n## 非递归遍历（中序）\n\n```\nvoid inOrderTraverse(TreeNode root) {\n\tif (root == null)\n\t\treturn;\n\t\n\tStack<TreeNode> stack = new Stack<>();\n\tTreeNode cur = root;\n\n\twhile (cur != NULL || !stack.empty()) {\n\n\t\twhile (cur != NULL) {\n\t\t\tstack.push(cur);\n\t\t\tcur = cur.left;\n\t\t}\n\n\t\tif (!stack.empty()) {\n\t\t\tcur = stack.pop();\n\t\t\tprint(cur.data);\n\t\t\tcur = cur.right;\n\t\t}\n\n\t}\n}\n```\n\n## 非递归遍历（后序）\n\n注意，只有在栈顶出现两次才能输出。\n\n```\nvoid postOrderTraverse(TreeNode root) {\n\tif (root == null)\n\t\treturn;\n\t\n\tStack<TreeNode> stack = new Stack<>();\n\tTreeNode cur = root;\n\tTreeNode last = null;\n\n\twhile(cur != null || !stack.empty()){\n        while (cur != null) {\n            stack.push(cur);\n            cur = cur.left;\n        }\n        \n        if (!stack.empty()) {\n            cur = stack.peek();\n            // 如果已经访问了右子树，则可以访问根节点；否则转向，先去访问右子树\n            if (cur.right == null || cur.right == last) {\n                results.add(cur.val);\n                stack.pop();\n                last = cur; // 表示已访问过\n                cur = null; // 表示不需要转向，继续弹栈\n            } else {\n                // 转向\n                cur = cur.right;\n            }\n        }\n    }\n}\n```","source":"_posts/二叉树总结.markdown","raw":"title: 二叉树算法总结\ndate: 2015-04-18 22:18:44\ntags: 数据结构与算法\n---\n\n二叉树的相关算法，建立、遍历等。\n\n<!--more-->\n\n## 二叉树类结构定义\n\n```\nclass TreeNode<T> {\n\tT data;\n\tTreeNode left, right;\n}\n```\n\n## 递归遍历（前序）\n\n```\nvoid preOrderTraverse(TreeNode root) {\n\tif (root == null)\n\t\treturn;\n\tprint(root.data);\n\tpreOrderTraverse(root.left);\n\tpreOrderTraverse(root.right);\n}\n```\n\n## 非递归遍历（前序）\n\n```\nvoid preOrderTraverse(TreeNode root) {\n\tif (root == null)\n\t\treturn;\n\t\n\tStack<TreeNode> stack = new Stack<>();\n\tTreeNode cur = root;\n\n\twhile (cur != null || !stack.empty()) {\n\n\t\twhile (cur != null) {\n\t\t\tprint(cur.data);\n\t\t\tstack.push(cur);\n\t\t\tcur = cur.left;\n\t\t}\n\n\t\tif (!stack.empty()) {\n\t\t\tcur = stack.pop();\n\t\t\tcur = cur.right;\n\t\t}\n\n\t}\t\n}\n```\n\n## 非递归遍历（中序）\n\n```\nvoid inOrderTraverse(TreeNode root) {\n\tif (root == null)\n\t\treturn;\n\t\n\tStack<TreeNode> stack = new Stack<>();\n\tTreeNode cur = root;\n\n\twhile (cur != NULL || !stack.empty()) {\n\n\t\twhile (cur != NULL) {\n\t\t\tstack.push(cur);\n\t\t\tcur = cur.left;\n\t\t}\n\n\t\tif (!stack.empty()) {\n\t\t\tcur = stack.pop();\n\t\t\tprint(cur.data);\n\t\t\tcur = cur.right;\n\t\t}\n\n\t}\n}\n```\n\n## 非递归遍历（后序）\n\n注意，只有在栈顶出现两次才能输出。\n\n```\nvoid postOrderTraverse(TreeNode root) {\n\tif (root == null)\n\t\treturn;\n\t\n\tStack<TreeNode> stack = new Stack<>();\n\tTreeNode cur = root;\n\tTreeNode last = null;\n\n\twhile(cur != null || !stack.empty()){\n        while (cur != null) {\n            stack.push(cur);\n            cur = cur.left;\n        }\n        \n        if (!stack.empty()) {\n            cur = stack.peek();\n            // 如果已经访问了右子树，则可以访问根节点；否则转向，先去访问右子树\n            if (cur.right == null || cur.right == last) {\n                results.add(cur.val);\n                stack.pop();\n                last = cur; // 表示已访问过\n                cur = null; // 表示不需要转向，继续弹栈\n            } else {\n                // 转向\n                cur = cur.right;\n            }\n        }\n    }\n}\n```","slug":"二叉树总结","published":1,"updated":"2017-10-16T09:23:15.123Z","_id":"cj75tmhvw000toa5xahn3iibz","comments":1,"layout":"post","photos":[],"link":""},{"layout":"post","title":"Ubuntu 下安装好 Wireshark 却找不到 Interface 的解决办法","date":"2015-06-10T07:25:33.000Z","comments":1,"_content":"\n今天在做网络攻防时需要在 Ubuntu 中使用 Wireshark 来抓取观察网络数据包，也就有了这篇文章。\n\n<!--more-->\n\n注：本篇文章非原创，部分内容参考：[http://www.94cat.com/blog/?p=1107](http://www.94cat.com/blog/?p=1107)\n\n1.安装 Wireshark\n\tUbuntu 下安装 Wireshark 的话直接从`软件中心`搜索安装即可\n\n2.启动 Wireshark\n\t直接启动 Wireshark 的话会发现 Interface 列表里为空（如果有蓝牙模块，会显示一个蓝牙的），可以使用 `sudo wireshark` 来启动，会有个错误信息，显示 Load Error，但是 Interface 正常，也可以正常使用，但不推荐这种做法。\n\n**3.推荐的方法--使用用户组功能使用 Wireshark**\n\n- 添加用户组，此处以 `wireshark` 用户组为例\n```\nsudo groupadd wireshark\n```\n\n- 将 dumpcap 更改为 wireshark 用户组\n```\nsudo chgrp wireshark /usr/bin/dumpcap\n```\n\n- 让 wireshark 用户组有 root 权限使用 dumpcap\n```\nsudo chmod 4755 /usr/bin/dumpcap\n```\n(PS:4754 Wireshark 还是会提示没有权限 )\n\n- 将当前用户加入 wireshark 用户组，我的用户是 `candice`，你添加需要更改这个。\n```\nsudo gpasswd -a candice wireshark\n```\n\n这样就完成了，你可以使用自己的用户打开 Wireshark，能够看到所有 Interface，并且有权限进行操作了。","source":"_posts/wireshark找不到interface.markdown","raw":"---\nlayout: post\ntitle: \"Ubuntu 下安装好 Wireshark 却找不到 Interface 的解决办法\"\ndate: 2015-06-10 15:25:33 +0800\ncomments: true\ntags: [Linux, Wireshark]\n---\n\n今天在做网络攻防时需要在 Ubuntu 中使用 Wireshark 来抓取观察网络数据包，也就有了这篇文章。\n\n<!--more-->\n\n注：本篇文章非原创，部分内容参考：[http://www.94cat.com/blog/?p=1107](http://www.94cat.com/blog/?p=1107)\n\n1.安装 Wireshark\n\tUbuntu 下安装 Wireshark 的话直接从`软件中心`搜索安装即可\n\n2.启动 Wireshark\n\t直接启动 Wireshark 的话会发现 Interface 列表里为空（如果有蓝牙模块，会显示一个蓝牙的），可以使用 `sudo wireshark` 来启动，会有个错误信息，显示 Load Error，但是 Interface 正常，也可以正常使用，但不推荐这种做法。\n\n**3.推荐的方法--使用用户组功能使用 Wireshark**\n\n- 添加用户组，此处以 `wireshark` 用户组为例\n```\nsudo groupadd wireshark\n```\n\n- 将 dumpcap 更改为 wireshark 用户组\n```\nsudo chgrp wireshark /usr/bin/dumpcap\n```\n\n- 让 wireshark 用户组有 root 权限使用 dumpcap\n```\nsudo chmod 4755 /usr/bin/dumpcap\n```\n(PS:4754 Wireshark 还是会提示没有权限 )\n\n- 将当前用户加入 wireshark 用户组，我的用户是 `candice`，你添加需要更改这个。\n```\nsudo gpasswd -a candice wireshark\n```\n\n这样就完成了，你可以使用自己的用户打开 Wireshark，能够看到所有 Interface，并且有权限进行操作了。","slug":"wireshark找不到interface","published":1,"updated":"2017-09-04T06:47:45.000Z","photos":[],"link":"","_id":"cj75tmhvy000voa5xmjalv807"},{"layout":"post","title":"设置 urllib 的访问超时时间","date":"2016-04-25T07:25:33.000Z","comments":1,"_content":"\n```\n\timport socket\n\tsocket.setdefaulttimeout(5.0)\n```\n\n<!--more-->\n\n今天用了 python 的 urllib 库，主要是想编写 sql 基于时间的盲注脚本，要通过网络访问超时来进行异常捕获。`urllib2.openurl(url, timeout=1)` 可以直接设置超时时间，但是 urllib 并不能这样，解决方法：\n\n```\n\timport socket\n\tsocket.setdefaulttimeout(5.0)\n```\n\n因为 urllib 是基于 socket 的，这样就设置了读取网络的超时时间为 5 秒，结合 try 来异常捕获的话，如下：\n\n```\n\timport socket\n\tsocket.setdefaulttimeout(5.0)\n\n\ttry:\n        urllib.urlopen(url).read()\n    except:\n        some operation\n        pass\n```","source":"_posts/python-urllib超时.markdown","raw":"---\nlayout: post\ntitle: \"设置 urllib 的访问超时时间\"\ndate: 2016-04-25 15:25:33 +0800\ncomments: true\ntags: Python\n---\n\n```\n\timport socket\n\tsocket.setdefaulttimeout(5.0)\n```\n\n<!--more-->\n\n今天用了 python 的 urllib 库，主要是想编写 sql 基于时间的盲注脚本，要通过网络访问超时来进行异常捕获。`urllib2.openurl(url, timeout=1)` 可以直接设置超时时间，但是 urllib 并不能这样，解决方法：\n\n```\n\timport socket\n\tsocket.setdefaulttimeout(5.0)\n```\n\n因为 urllib 是基于 socket 的，这样就设置了读取网络的超时时间为 5 秒，结合 try 来异常捕获的话，如下：\n\n```\n\timport socket\n\tsocket.setdefaulttimeout(5.0)\n\n\ttry:\n        urllib.urlopen(url).read()\n    except:\n        some operation\n        pass\n```","slug":"python-urllib超时","published":1,"updated":"2017-09-04T07:29:39.000Z","_id":"cj75tmhvz000yoa5xo4u5ja7s","photos":[],"link":""},{"title":"mac工具--通过 arp 欺骗抓取局域网内设备数据包","date":"2016-07-23T14:18:44.000Z","_content":"\n\n使用 `Debookee` 抓取同局域网内设备数据包，太神奇了。\n\n<!--more-->\n\n因为有个需求，就是想看某手机app内部网络部分是如何实现的，所以要抓取其数据包（主要是 Http 协议部分），Windows 下可以用 Fidder 为手机设置代理实现，Mac 下有一款 `Debookee` 的软件可以实现同样的功能，但是原理不同 Fidder 设置代理。首先先看截图：\n\n这是扫出来的局域网内所有主机情况：\n\n![扫描主机列表](http://7xivx9.com1.z0.glb.clouddn.com/debookeedebookee_list.png)\n\n将目标主机设置为 target，此处是我的手机，然后再点击左上角的 `Start Dbk`，就会抓取到手机上的数据包，如图：\n\n![抓手机数据包](http://7xivx9.com1.z0.glb.clouddn.com/debookeedebookee_phone.png)\n\n很神奇，什么都不用设置，只要在 `Debookee` 上点几下，同个局域网中所有设备数据包我都能监控到了。基于什么原理呢？\n\n我的另一台 Samsung 电脑打开了 Wireshark 抓取数据包，发现 `Debookee` 只要一扫描或者对其抓包，就会有满屏幕的 ARP 欺骗--所以原理也就清楚了，是`基于 ARP 欺骗`的（感谢大哥教导），如图：\n\n![ARP 欺骗](http://7xivx9.com1.z0.glb.clouddn.com/debookeedebookee_arp.jpg)\n\n其实很简单，最后，视频演示下吧：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/debookeeDebookee.mp4\" controls=\"controls\"></video>\n</div>\n\n总的来说，这款工具非常好用！—— `Debookee`\n\n另外，还有另一种方式，即通过`设置中间代理`的方式来抓包，在我的这篇文章中有讲解 \"Charles 的安装破解与使用\"","source":"_posts/mac下抓包工具--Debookee.markdown","raw":"title: mac工具--通过 arp 欺骗抓取局域网内设备数据包\ndate: 2016-07-23 22:18:44\ntags: Mac\n---\n\n\n使用 `Debookee` 抓取同局域网内设备数据包，太神奇了。\n\n<!--more-->\n\n因为有个需求，就是想看某手机app内部网络部分是如何实现的，所以要抓取其数据包（主要是 Http 协议部分），Windows 下可以用 Fidder 为手机设置代理实现，Mac 下有一款 `Debookee` 的软件可以实现同样的功能，但是原理不同 Fidder 设置代理。首先先看截图：\n\n这是扫出来的局域网内所有主机情况：\n\n![扫描主机列表](http://7xivx9.com1.z0.glb.clouddn.com/debookeedebookee_list.png)\n\n将目标主机设置为 target，此处是我的手机，然后再点击左上角的 `Start Dbk`，就会抓取到手机上的数据包，如图：\n\n![抓手机数据包](http://7xivx9.com1.z0.glb.clouddn.com/debookeedebookee_phone.png)\n\n很神奇，什么都不用设置，只要在 `Debookee` 上点几下，同个局域网中所有设备数据包我都能监控到了。基于什么原理呢？\n\n我的另一台 Samsung 电脑打开了 Wireshark 抓取数据包，发现 `Debookee` 只要一扫描或者对其抓包，就会有满屏幕的 ARP 欺骗--所以原理也就清楚了，是`基于 ARP 欺骗`的（感谢大哥教导），如图：\n\n![ARP 欺骗](http://7xivx9.com1.z0.glb.clouddn.com/debookeedebookee_arp.jpg)\n\n其实很简单，最后，视频演示下吧：\n\n<div class=\"video-container\">\n\t<video src=\"http://7xivx9.com1.z0.glb.clouddn.com/debookeeDebookee.mp4\" controls=\"controls\"></video>\n</div>\n\n总的来说，这款工具非常好用！—— `Debookee`\n\n另外，还有另一种方式，即通过`设置中间代理`的方式来抓包，在我的这篇文章中有讲解 \"Charles 的安装破解与使用\"","slug":"mac下抓包工具--Debookee","published":1,"updated":"2017-09-04T07:29:26.000Z","_id":"cj75tmhw10010oa5xp51sfclp","comments":1,"layout":"post","photos":[],"link":""},{"title":"mac抓包工具--Charles","date":"2016-08-30T14:18:44.000Z","_content":"\n上篇文章介绍了 Mac 中抓局域网数据包的使用方法，主要是基于 ARP 欺骗。这次将要介绍的 Charles 的原理是`设置中间代理`来完成抓包的工作。\n\n<!--more-->\n\n# Charles 的安装与破解（都是程序员，女人何必为难女人）\n\n - 下载原版 Charles 路径：[我的七牛云存储](http://7xivx9.com1.z0.glb.clouddn.com/charles-proxy-3.10.2.dmg) or [官网](http://www.charlesproxy.com/download/)，并正常安装（此版本为 3.10.2，目前为官网最新）\n - 下载破解 jar 包：[我的七牛云存储](http://7xivx9.com1.z0.glb.clouddn.com/charles.jar)\n - 显示 Charles 包的内容\n \t![image](http://7xivx9.com1.z0.glb.clouddn.com/charles-cracker-1.png)\n - 替换 `charles.jar`\n \t![image](http://7xivx9.com1.z0.glb.clouddn.com/charles-cracker-2.png)\n - 完成，打开即可使用\n\n# 使用 Charles 抓取网络请求\n\n参考文章 : [使用Charles抓取App网络请求](http://www.brighttj.com/ios/ios-use-charles-fetch-web-request-in-app.html)","source":"_posts/mac下抓包工具--Charles.markdown","raw":"title: mac抓包工具--Charles\ndate: 2016-08-30 22:18:44\ntags: Mac\n---\n\n上篇文章介绍了 Mac 中抓局域网数据包的使用方法，主要是基于 ARP 欺骗。这次将要介绍的 Charles 的原理是`设置中间代理`来完成抓包的工作。\n\n<!--more-->\n\n# Charles 的安装与破解（都是程序员，女人何必为难女人）\n\n - 下载原版 Charles 路径：[我的七牛云存储](http://7xivx9.com1.z0.glb.clouddn.com/charles-proxy-3.10.2.dmg) or [官网](http://www.charlesproxy.com/download/)，并正常安装（此版本为 3.10.2，目前为官网最新）\n - 下载破解 jar 包：[我的七牛云存储](http://7xivx9.com1.z0.glb.clouddn.com/charles.jar)\n - 显示 Charles 包的内容\n \t![image](http://7xivx9.com1.z0.glb.clouddn.com/charles-cracker-1.png)\n - 替换 `charles.jar`\n \t![image](http://7xivx9.com1.z0.glb.clouddn.com/charles-cracker-2.png)\n - 完成，打开即可使用\n\n# 使用 Charles 抓取网络请求\n\n参考文章 : [使用Charles抓取App网络请求](http://www.brighttj.com/ios/ios-use-charles-fetch-web-request-in-app.html)","slug":"mac下抓包工具--Charles","published":1,"updated":"2017-09-04T07:29:18.000Z","_id":"cj75tmhw40012oa5xo6sll49l","comments":1,"layout":"post","photos":[],"link":""},{"layout":"post","title":"Ubuntu12.04 管理员无法登录桌面，只能guest登录","date":"2015-05-03T07:25:33.000Z","comments":1,"_content":"\n今天使用Ubuntu的时候遇到了一个问题，在登录界面输入正确的管理员密码后却无法登录到桌面，一直在那里循环，访客模式就可以登录进桌面，网上查了一下，找到了解决办法。\n\n<!--more-->\n\n解决办法步骤如下：\n\n- 在登录界面按下  `Ctrl + Alt + F1` 切换到tty， 输入管理员账号和密码\n- 输入 `sudo rm -r .Xauthority*`\n- 输入 `sudo reboot`\n\nOK，解决~\n\n截图如下：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/Ubuntu1204.png)","source":"_posts/Ubuntu1204无法登录桌面.markdown","raw":"---\nlayout: post\ntitle: \"Ubuntu12.04 管理员无法登录桌面，只能guest登录\"\ndate: 2015-05-03 15:25:33 +0800\ncomments: true\ntags: Linux\n---\n\n今天使用Ubuntu的时候遇到了一个问题，在登录界面输入正确的管理员密码后却无法登录到桌面，一直在那里循环，访客模式就可以登录进桌面，网上查了一下，找到了解决办法。\n\n<!--more-->\n\n解决办法步骤如下：\n\n- 在登录界面按下  `Ctrl + Alt + F1` 切换到tty， 输入管理员账号和密码\n- 输入 `sudo rm -r .Xauthority*`\n- 输入 `sudo reboot`\n\nOK，解决~\n\n截图如下：\n\n![image](http://7xivx9.com1.z0.glb.clouddn.com/Ubuntu1204.png)","slug":"Ubuntu1204无法登录桌面","published":1,"updated":"2017-09-04T06:48:45.000Z","photos":[],"link":"","_id":"cj75tmhw50014oa5xsug5gyfq"},{"title":"Java 字符集与编码","date":"2016-09-13T14:18:44.000Z","_content":"\n读《Java 特种兵》总结之前不会的相关知识。\n\n<!--more-->\n\nJava 中的 char 是 UTF-16 编码，每个字符占两个字节的宽度。\n\n例如发送 2 个汉字，用 UTF-8 编码发送后会占用 6 个字节，对方若知道传来的数据是 UTF-8 编码，便知道这 6 个字节代表哪 2 个汉字，就自然能得到正确的 char 字符了。但是如果对方用 GBK 来编码，则可能会认为有 3 个字符，若按照每 2 个字节计算 1 个字符，得到的 3 个字符自然不是需要传递的 2 个汉字字符。假如此时意识到自己的编码错误了，通过得到的 3 个字符的字符串调用 getBytes(\"GBK\") 还可以还原 6 个字节，然后通过这 6 个字节再用 new String(byte[], \"UTF-8\") 得到实际的 2 个汉字。可真的是这样嘛？要知道这是偶然的，不是必然的，因为 UTF-8 转换出来的 6 个字节，当按照每 2 个字节组成编码时，这个编码未必在 GBK 的编码范围内，若不在 GBK 的编码范围内，就可能会用一个 \"?\" 或其他字符来代表，由于 \"?\" 本身也是一个字符，当再次调用 getBytes(\"GBK\") 时得到的对应字节就是 \"?\" 对应的字节，而不是原来字符的字节，有可能都不再是 6 个字节了。换句话说，这样的情况是永远无法转换回来的。","source":"_posts/Java字符集与编码.markdown","raw":"title: Java 字符集与编码\ndate: 2016-09-13 22:18:44\ntags: Java\n---\n\n读《Java 特种兵》总结之前不会的相关知识。\n\n<!--more-->\n\nJava 中的 char 是 UTF-16 编码，每个字符占两个字节的宽度。\n\n例如发送 2 个汉字，用 UTF-8 编码发送后会占用 6 个字节，对方若知道传来的数据是 UTF-8 编码，便知道这 6 个字节代表哪 2 个汉字，就自然能得到正确的 char 字符了。但是如果对方用 GBK 来编码，则可能会认为有 3 个字符，若按照每 2 个字节计算 1 个字符，得到的 3 个字符自然不是需要传递的 2 个汉字字符。假如此时意识到自己的编码错误了，通过得到的 3 个字符的字符串调用 getBytes(\"GBK\") 还可以还原 6 个字节，然后通过这 6 个字节再用 new String(byte[], \"UTF-8\") 得到实际的 2 个汉字。可真的是这样嘛？要知道这是偶然的，不是必然的，因为 UTF-8 转换出来的 6 个字节，当按照每 2 个字节组成编码时，这个编码未必在 GBK 的编码范围内，若不在 GBK 的编码范围内，就可能会用一个 \"?\" 或其他字符来代表，由于 \"?\" 本身也是一个字符，当再次调用 getBytes(\"GBK\") 时得到的对应字节就是 \"?\" 对应的字节，而不是原来字符的字节，有可能都不再是 6 个字节了。换句话说，这样的情况是永远无法转换回来的。","slug":"Java字符集与编码","published":1,"updated":"2017-09-04T07:29:03.000Z","_id":"cj75tmhw70016oa5x0cnxt0ej","comments":1,"layout":"post","photos":[],"link":""},{"layout":"post","title":"Java 实现 AES 算法","date":"2014-10-31T07:20:33.000Z","comments":1,"_content":"\n密码学课上学习了AES算法，balabala原理上有些听不懂，如果是日常应用，可以用java实现好的东西来搬过来用。\n\n<!--more-->\n\n首先建了一个自己的AES工具类，里面写上了静态的加密和解密函数供之后使用。\n\nAES工具类和加解密函数如下：\n{% codeblock lang:java %}\npublic class MyAESUtils {\n\tpublic static byte[] encrypt(String content, String password) {\n\t\ttry {\n\t\t\tKeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n\t\t\tkgen.init(128, new SecureRandom(password.getBytes()));\t\t\tSecretKey secretKey = kgen.generateKey();\n\t\t\tbyte[] enCodeFormat = secretKey.getEncoded();\n\t\t\tSecretKeySpec key = new SecretKeySpec(enCodeFormat, \"AES\");\n\t\t\tCipher cipher = Cipher.getInstance(\"AES\");\n\t\t\tbyte[] byteContent = content.getBytes(\"utf-8\");\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, key);\n\t\t\tbyte[] result = cipher.doFinal(byteContent);\n\t\t\treturn result;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static byte[] decrypt(byte[] content, String password) {\n\t\ttry {\n\t\t\tKeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n\t\t\tkgen.init(128, new SecureRandom(password.getBytes()));\n\t\t\tSecretKey secretKey = kgen.generateKey();\n\t\t\tbyte[] enCodeFormat = secretKey.getEncoded();\n\t\t\tSecretKeySpec key = new SecretKeySpec(enCodeFormat, \"AES\");\n\t\t\tCipher cipher = Cipher.getInstance(\"AES\");\n\t\t\tcipher.init(Cipher.DECRYPT_MODE, key);\n\t\t\tbyte[] result = cipher.doFinal(content);\n\t\t\treturn result;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\t\n}\n{% endcodeblock %}\n\n以上的类库不需要额外的jar包，直接在Eclipse里按`Ctrl+O`快捷键自动导入就好了。接下来实现主函数：\n\n\tpublic class AESMain {\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tSystem.out.println(\"请输入明文\");\n\t\t\tString content = in.nextLine();\n\t\t\tSystem.out.println(\"请输入密钥\");\n\t\t\tString key = in.nextLine();\n\t\t\t\n\t\t\tbyte[] encryptResult = MyAESUtils.encrypt(content, key);\n\t\t\tSystem.out.println(\"加密后密文为： \" + encryptResult);\n\t\t\t\n\t\t\tbyte[] decryptResult = MyAESUtils.decrypt(encryptResult, key);\n\t\t\tSystem.out.println(\"解密后原文为： \" + new String(decryptResult));\n\t\n\t\t}\n\t}\n\n很简单的一段代码就实现了基于AES算法的加解密，不过仅仅这样做还是不懂AES的原理的，就需要阅读源码看一下了。不过应用的话，这样基本上就行了。","source":"_posts/Java 实现 AES 算法.markdown","raw":"---\nlayout: post\ntitle: \"Java 实现 AES 算法\"\ndate: 2014-10-31 15:20:33 +0800\ncomments: true\ntags: [Java, AES]\n---\n\n密码学课上学习了AES算法，balabala原理上有些听不懂，如果是日常应用，可以用java实现好的东西来搬过来用。\n\n<!--more-->\n\n首先建了一个自己的AES工具类，里面写上了静态的加密和解密函数供之后使用。\n\nAES工具类和加解密函数如下：\n{% codeblock lang:java %}\npublic class MyAESUtils {\n\tpublic static byte[] encrypt(String content, String password) {\n\t\ttry {\n\t\t\tKeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n\t\t\tkgen.init(128, new SecureRandom(password.getBytes()));\t\t\tSecretKey secretKey = kgen.generateKey();\n\t\t\tbyte[] enCodeFormat = secretKey.getEncoded();\n\t\t\tSecretKeySpec key = new SecretKeySpec(enCodeFormat, \"AES\");\n\t\t\tCipher cipher = Cipher.getInstance(\"AES\");\n\t\t\tbyte[] byteContent = content.getBytes(\"utf-8\");\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, key);\n\t\t\tbyte[] result = cipher.doFinal(byteContent);\n\t\t\treturn result;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic static byte[] decrypt(byte[] content, String password) {\n\t\ttry {\n\t\t\tKeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n\t\t\tkgen.init(128, new SecureRandom(password.getBytes()));\n\t\t\tSecretKey secretKey = kgen.generateKey();\n\t\t\tbyte[] enCodeFormat = secretKey.getEncoded();\n\t\t\tSecretKeySpec key = new SecretKeySpec(enCodeFormat, \"AES\");\n\t\t\tCipher cipher = Cipher.getInstance(\"AES\");\n\t\t\tcipher.init(Cipher.DECRYPT_MODE, key);\n\t\t\tbyte[] result = cipher.doFinal(content);\n\t\t\treturn result;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\t\n}\n{% endcodeblock %}\n\n以上的类库不需要额外的jar包，直接在Eclipse里按`Ctrl+O`快捷键自动导入就好了。接下来实现主函数：\n\n\tpublic class AESMain {\n\t\tpublic static void main(String[] args) {\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tSystem.out.println(\"请输入明文\");\n\t\t\tString content = in.nextLine();\n\t\t\tSystem.out.println(\"请输入密钥\");\n\t\t\tString key = in.nextLine();\n\t\t\t\n\t\t\tbyte[] encryptResult = MyAESUtils.encrypt(content, key);\n\t\t\tSystem.out.println(\"加密后密文为： \" + encryptResult);\n\t\t\t\n\t\t\tbyte[] decryptResult = MyAESUtils.decrypt(encryptResult, key);\n\t\t\tSystem.out.println(\"解密后原文为： \" + new String(decryptResult));\n\t\n\t\t}\n\t}\n\n很简单的一段代码就实现了基于AES算法的加解密，不过仅仅这样做还是不懂AES的原理的，就需要阅读源码看一下了。不过应用的话，这样基本上就行了。","slug":"Java 实现 AES 算法","published":1,"updated":"2017-09-04T06:52:18.000Z","photos":[],"link":"","_id":"cj75tmhw90018oa5xx48ygysa"},{"title":"搭建Jenkins环境构建Maven","date":"2017-06-30T07:04:44.000Z","_content":"\n讲解如何使用Jenkins做持续集成。\n\n<!--more-->\n\n## Jenkins的部署\n在其官网上下载 Jenkins.war 包放在服务器的 Tomcat 容器中即可，直接访问服务器地址，进入Jenkins后设置登录的用户信息。\n\n## Jenkins的配置\n\n### 插件\n(1)在进行配置之前，由于使用的是 Git 拉去代码的方式，所以要首先安装插件。\n![Git](http://img.blog.csdn.net/20151218194433833)\n\n(2)因为要部署到远端的服务器，所以还需要安装\"Deploy to container Plugin\"插件，如图\n![Deploy to container Plugin](http://img.blog.csdn.net/20151218193834804)\n\n安装好之后重启即可\n\n## 新建Job\n\n创建一个新任务，构建一个自由风格的软件项目，源码管理选择Git，并配置好仓库的信息，构建的触发器为当BitBucket有新的代码提交时，如下图所示\n![Jenkins1](http://7xivx9.com1.z0.glb.clouddn.com/jenkins1.png)\n\n具体构建时，保存本次构建的 COMMIT_ID 和 TASK_ID 方便查看本次构建结果，如下图\n![Jenkins2](http://7xivx9.com1.z0.glb.clouddn.com/jenkins2.png)\n\n构建之后就要部署，使用\"Deploy to container Plugin\"插件，写好相关的信息即可，如下图\n![Jenkins3](http://7xivx9.com1.z0.glb.clouddn.com/jenkins3.png)\n\n## 参考文章\n\n[自动构建](https://wiki.jenkins.io/display/JENKINS/BitBucket+Plugin)","source":"_posts/jenkins.markdown","raw":"title: 搭建Jenkins环境构建Maven\ndate: 2017-06-30 15:04:44 \ntags: Jenkins\n----\n\n讲解如何使用Jenkins做持续集成。\n\n<!--more-->\n\n## Jenkins的部署\n在其官网上下载 Jenkins.war 包放在服务器的 Tomcat 容器中即可，直接访问服务器地址，进入Jenkins后设置登录的用户信息。\n\n## Jenkins的配置\n\n### 插件\n(1)在进行配置之前，由于使用的是 Git 拉去代码的方式，所以要首先安装插件。\n![Git](http://img.blog.csdn.net/20151218194433833)\n\n(2)因为要部署到远端的服务器，所以还需要安装\"Deploy to container Plugin\"插件，如图\n![Deploy to container Plugin](http://img.blog.csdn.net/20151218193834804)\n\n安装好之后重启即可\n\n## 新建Job\n\n创建一个新任务，构建一个自由风格的软件项目，源码管理选择Git，并配置好仓库的信息，构建的触发器为当BitBucket有新的代码提交时，如下图所示\n![Jenkins1](http://7xivx9.com1.z0.glb.clouddn.com/jenkins1.png)\n\n具体构建时，保存本次构建的 COMMIT_ID 和 TASK_ID 方便查看本次构建结果，如下图\n![Jenkins2](http://7xivx9.com1.z0.glb.clouddn.com/jenkins2.png)\n\n构建之后就要部署，使用\"Deploy to container Plugin\"插件，写好相关的信息即可，如下图\n![Jenkins3](http://7xivx9.com1.z0.glb.clouddn.com/jenkins3.png)\n\n## 参考文章\n\n[自动构建](https://wiki.jenkins.io/display/JENKINS/BitBucket+Plugin)","slug":"jenkins","published":1,"updated":"2017-09-04T07:46:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj75v3sig0000uz5x4w0rgsu3"},{"title":"必备Linux常用命令概要","date":"2017-03-12T07:04:44.000Z","_content":"\n记录下常见必备的Linux命令，方便日后回顾。\n\n<!--more-->\n\n## 两个很有用的网站\n\n[软件测试人员必备Linux命令](http://www.cnblogs.com/Javame/p/3968343.html)\n\n[Linux命令速查](http://man.linuxde.net/)\n\n## CheckList\n\n- cat 查看文件内容\n- chmod 修改文件权限\n- chown 将文件的所有者修改为另一个用户\n- find 查找文件名\n- file 查看文件的内容类型\n- mkdir 创建目录\n- more、less 分页查看（空格下一页 B上一页）\n- head、tail 查看文件头部、尾部  默认10行\n- mv、cp  移动 拷贝\n- rm(`rm -rf folder_name`) 移除\n- which(显示一个命令的真实地址，如 which git)\n- scp(`scp sedstudy.txt root@47.94.89.226:~/sedstudycopy.txt`) 在两台主机之间进行文件的拷贝\n- awk\n- grep 过滤\n- sed\n- look\n- wc\n- cd\n- pwd(显示当前的绝对路径)\n- mount umount(挂载和卸载设备)\n- ls (ls -lsa     ll) 查看文件\n- telnet(查看47.x主机的80端口是否开放 `telnet 47.94.89.226 80`)\n- ifconfig 查看网络设置\n- ping \n- netstat \t\n- kill(kill pid)\n- ps(最常用的是ps -aux，可以再结合grep，如查找ssh的进程pid号-> `ps -aux | grep ssh`)\n- free(-b:B -k:KB -m:MB -t:Total) 查看内存的使用情况\n- top(需要查一下各个字段的含义)\n- shutdown(现在关机:`shutdown -h now`  现在重启:`shutdown -r now`)\n- sudo 以超级管理员的身份执行命令\n- who(显示目前登录系统的用户信息)\n- whoami(显示当前有效的用户名称)\n- su 切换用户\n- clear\n- crontab(定时/定期执行命令或脚本)\n- tar 压缩 解压\n- source(链接shell) 配置文件生效（服务器配Java环境）\n- \\>覆盖 \\>\\>追加\n- man\t查看命令帮助\n- curl 访问url或下载文件(访问并过滤->`curl http://zhouwut.cn | grep better`   下载文件->`curl -o filename.html http://zhouwut.cn/index.html`  -o是output)\n- wget 下载文件(`wget http://zhouwut.cn/index.html`)\n\n\n## 备忘\n\n### sed命令\n\nTODO\nAND\n\n#### 增\n第2行下增加sth\nsed '2a sth' \n\n2-5行每行的下一行增加sth\nsed '2,5a sth' \n\n2-最后一行每行的下一行增加sth\nsed '2,$a sth' \n\n2行前增加sth\nsed '2i sth'\n\n#### 删\n删除第2-5行\nsed '2,5d'\n\n#### 替换 c->取代\n2-5行的内容为一行的sth\nsed '2,5c sth'\n\n#### 查\n只显示2-5行的内容(Todo：加不加-n会有区别，不知道为什么)\nsed -n '2,5p'\n\n搜寻有sth关键字的行\nsed -n '/sth/p'\n\n只显示不包含sth的行\nsed '/sth/d'\n\n打印第一个找到的first行到第4行的内容\nsed -n '/first/, 4p'\n\n#### 字符串替换\nsed 's/origin/after/g'\n\n删除包含delme和delmine\nsed 's/delme//g' | sed 's/delmine//g'\n\n直接对源文件修改\nsed -i 's/first/second/g' filename\n\n### awk\n\nawk [-F  field-separator]  'commands'\n\nawk依次会读入每一行，并以每一行为单位进行操作\n\n显示以:分割的每行的第一个元素\ncat /etc/passwd | awk -F ':' '{print $1}'\n\n显示以:分割的每行的第一个、和第七个元素，输出时中间加个逗号\ncat /etc/passwd | awk -F ':' '{print $1 \",\" $7}'\n\n同上，但是在开头和结尾添加自定义内容\ncat /etc/passwd | awk -F ':' 'BEGIN {print \"name, shell\"} {print $1 \",\" $7} END {print \"I am the end.\"}'\n\n搜索/etc/passwd中以root关键字开头的所有行，并显示对应的第一个和第七个元素(/pattern/，其中pattern支持正则)\ncat /etc/passwd | awk -F ':' '/^root/{print $1, $7}'\n\n\n### wc - word count\n\n基本命令\n-c chars bytes 统计字节数\n-l lines 统计行数\n-m 统计字符数。这个标志不能与 -c 标志一起使用，结果一般与-c相同\n-w words 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串\n-L 打印最长行的长度\n\nwc 命令 文件名\n\n显示行数\nwc -l /etc/passwd\n\n显示单词数\nwc -w /etc/passwd\n\n显示字节数(字符数)\nwc -c /etc/passwd\n\n显示行数+单词数+字节数\nwc /etc/passwd\n\n\n### look\n\n查询每行以某个字符串开头的所有行\nlook root /etc/passwd\n\n\n### netstat\n\n-a (all)显示所有选项，默认不显示LISTEN相关\n-t (tcp)仅显示tcp相关选项\n-u (udp)仅显示udp相关选项\n-n 拒绝显示别名，能显示数字的全部转化成数字。\n-l 仅列出有在 Listen (监听) 的服務状态\n\n-p 显示建立相关链接的程序名\n-r 显示路由信息，路由表\n-e 显示扩展信息，例如uid等\n-s 按各个协议进行统计\n-c 每隔一个固定时间，执行该netstat命令。\n\n以上参数都可组合使用，如 netstat -atul\n\n列出所有的tcp端口\nnetstat -at\n\n列出所有正在监听的udp端口\nnetstat -alu\n\n显示ssh进程占用的端口\nnetstat -ap | grep ssh","source":"_posts/linux-command.markdown","raw":"title: 必备Linux常用命令概要\ndate: 2017-03-12 15:04:44 \ntags: Linux\n----\n\n记录下常见必备的Linux命令，方便日后回顾。\n\n<!--more-->\n\n## 两个很有用的网站\n\n[软件测试人员必备Linux命令](http://www.cnblogs.com/Javame/p/3968343.html)\n\n[Linux命令速查](http://man.linuxde.net/)\n\n## CheckList\n\n- cat 查看文件内容\n- chmod 修改文件权限\n- chown 将文件的所有者修改为另一个用户\n- find 查找文件名\n- file 查看文件的内容类型\n- mkdir 创建目录\n- more、less 分页查看（空格下一页 B上一页）\n- head、tail 查看文件头部、尾部  默认10行\n- mv、cp  移动 拷贝\n- rm(`rm -rf folder_name`) 移除\n- which(显示一个命令的真实地址，如 which git)\n- scp(`scp sedstudy.txt root@47.94.89.226:~/sedstudycopy.txt`) 在两台主机之间进行文件的拷贝\n- awk\n- grep 过滤\n- sed\n- look\n- wc\n- cd\n- pwd(显示当前的绝对路径)\n- mount umount(挂载和卸载设备)\n- ls (ls -lsa     ll) 查看文件\n- telnet(查看47.x主机的80端口是否开放 `telnet 47.94.89.226 80`)\n- ifconfig 查看网络设置\n- ping \n- netstat \t\n- kill(kill pid)\n- ps(最常用的是ps -aux，可以再结合grep，如查找ssh的进程pid号-> `ps -aux | grep ssh`)\n- free(-b:B -k:KB -m:MB -t:Total) 查看内存的使用情况\n- top(需要查一下各个字段的含义)\n- shutdown(现在关机:`shutdown -h now`  现在重启:`shutdown -r now`)\n- sudo 以超级管理员的身份执行命令\n- who(显示目前登录系统的用户信息)\n- whoami(显示当前有效的用户名称)\n- su 切换用户\n- clear\n- crontab(定时/定期执行命令或脚本)\n- tar 压缩 解压\n- source(链接shell) 配置文件生效（服务器配Java环境）\n- \\>覆盖 \\>\\>追加\n- man\t查看命令帮助\n- curl 访问url或下载文件(访问并过滤->`curl http://zhouwut.cn | grep better`   下载文件->`curl -o filename.html http://zhouwut.cn/index.html`  -o是output)\n- wget 下载文件(`wget http://zhouwut.cn/index.html`)\n\n\n## 备忘\n\n### sed命令\n\nTODO\nAND\n\n#### 增\n第2行下增加sth\nsed '2a sth' \n\n2-5行每行的下一行增加sth\nsed '2,5a sth' \n\n2-最后一行每行的下一行增加sth\nsed '2,$a sth' \n\n2行前增加sth\nsed '2i sth'\n\n#### 删\n删除第2-5行\nsed '2,5d'\n\n#### 替换 c->取代\n2-5行的内容为一行的sth\nsed '2,5c sth'\n\n#### 查\n只显示2-5行的内容(Todo：加不加-n会有区别，不知道为什么)\nsed -n '2,5p'\n\n搜寻有sth关键字的行\nsed -n '/sth/p'\n\n只显示不包含sth的行\nsed '/sth/d'\n\n打印第一个找到的first行到第4行的内容\nsed -n '/first/, 4p'\n\n#### 字符串替换\nsed 's/origin/after/g'\n\n删除包含delme和delmine\nsed 's/delme//g' | sed 's/delmine//g'\n\n直接对源文件修改\nsed -i 's/first/second/g' filename\n\n### awk\n\nawk [-F  field-separator]  'commands'\n\nawk依次会读入每一行，并以每一行为单位进行操作\n\n显示以:分割的每行的第一个元素\ncat /etc/passwd | awk -F ':' '{print $1}'\n\n显示以:分割的每行的第一个、和第七个元素，输出时中间加个逗号\ncat /etc/passwd | awk -F ':' '{print $1 \",\" $7}'\n\n同上，但是在开头和结尾添加自定义内容\ncat /etc/passwd | awk -F ':' 'BEGIN {print \"name, shell\"} {print $1 \",\" $7} END {print \"I am the end.\"}'\n\n搜索/etc/passwd中以root关键字开头的所有行，并显示对应的第一个和第七个元素(/pattern/，其中pattern支持正则)\ncat /etc/passwd | awk -F ':' '/^root/{print $1, $7}'\n\n\n### wc - word count\n\n基本命令\n-c chars bytes 统计字节数\n-l lines 统计行数\n-m 统计字符数。这个标志不能与 -c 标志一起使用，结果一般与-c相同\n-w words 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串\n-L 打印最长行的长度\n\nwc 命令 文件名\n\n显示行数\nwc -l /etc/passwd\n\n显示单词数\nwc -w /etc/passwd\n\n显示字节数(字符数)\nwc -c /etc/passwd\n\n显示行数+单词数+字节数\nwc /etc/passwd\n\n\n### look\n\n查询每行以某个字符串开头的所有行\nlook root /etc/passwd\n\n\n### netstat\n\n-a (all)显示所有选项，默认不显示LISTEN相关\n-t (tcp)仅显示tcp相关选项\n-u (udp)仅显示udp相关选项\n-n 拒绝显示别名，能显示数字的全部转化成数字。\n-l 仅列出有在 Listen (监听) 的服務状态\n\n-p 显示建立相关链接的程序名\n-r 显示路由信息，路由表\n-e 显示扩展信息，例如uid等\n-s 按各个协议进行统计\n-c 每隔一个固定时间，执行该netstat命令。\n\n以上参数都可组合使用，如 netstat -atul\n\n列出所有的tcp端口\nnetstat -at\n\n列出所有正在监听的udp端口\nnetstat -alu\n\n显示ssh进程占用的端口\nnetstat -ap | grep ssh","slug":"linux-command","published":1,"updated":"2017-10-16T03:26:25.235Z","_id":"cj8srx0o10000ig380nzhy8ae","comments":1,"layout":"post","photos":[],"link":""}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj74dxev90009lr01giyko6nv","tag_id":"cj74dxeva000alr01nyc8lexh","_id":"cj74dxeva000blr01brd72crq"},{"post_id":"cj74dxevb000clr01zvrbfbtt","tag_id":"cj74dxevb000dlr01xthbr8eb","_id":"cj74dxevc000elr01ajqy0xu7"},{"post_id":"cj75tmhv90004oa5x67yikmxb","tag_id":"cj74dxets0001lr01a616adon","_id":"cj75tmhvb0005oa5x0kjx7odv"},{"post_id":"cj75tmhv90004oa5x67yikmxb","tag_id":"cj74dxewg001zlr01st121hbq","_id":"cj75tmhvb0006oa5xoxjv1eme"},{"post_id":"cj75tmhv90004oa5x67yikmxb","tag_id":"cj74dxewg0020lr015bfdhesy","_id":"cj75tmhvb0007oa5xqtxzwqsu"},{"post_id":"cj75tmhvc0008oa5x64p98y38","tag_id":"cj74dxets0001lr01a616adon","_id":"cj75tmhve0009oa5x6qqaz8hw"},{"post_id":"cj75tmhvc0008oa5x64p98y38","tag_id":"cj74dxewd001vlr01076jsmy9","_id":"cj75tmhve000aoa5x0jjjfq6e"},{"post_id":"cj75tmhvf000boa5xx660g896","tag_id":"cj74dxew1001glr01fygr37z0","_id":"cj75tmhvh000coa5xj2u3fwqw"},{"post_id":"cj75tmhvi000doa5xxb3celkh","tag_id":"cj74dxevh000mlr01z4kydv8t","_id":"cj75tmhvj000eoa5xdbrqixa0"},{"post_id":"cj75tmhvk000foa5xoos2zvfe","tag_id":"cj74dxevj000plr01ad165f8g","_id":"cj75tmhvl000goa5xy1y3tdfy"},{"post_id":"cj75tmhvm000hoa5xi6ep8fnr","tag_id":"cj74dxevs0011lr01nkz20rq4","_id":"cj75tmhvn000ioa5xlbbugku0"},{"post_id":"cj75tmhvm000hoa5xi6ep8fnr","tag_id":"cj74dxew9001plr01101gda6g","_id":"cj75tmhvn000joa5xv3kmc1ek"},{"post_id":"cj75tmhvo000koa5x9gn9am0m","tag_id":"cj74dxevj000plr01ad165f8g","_id":"cj75tmhvo000loa5xvmwjbfxg"},{"post_id":"cj75tmhvp000moa5xqizlyl5l","tag_id":"cj74dxevj000plr01ad165f8g","_id":"cj75tmhvq000noa5x9jovcv8q"},{"post_id":"cj75tmhvr000ooa5xeslpvxya","tag_id":"cj74dxevu0014lr01j9zrwbap","_id":"cj75tmhvs000poa5xcqruu4rc"},{"post_id":"cj75tmhvr000ooa5xeslpvxya","tag_id":"cj74dxevu0015lr01p6m3294k","_id":"cj75tmhvs000qoa5xcju7jq5p"},{"post_id":"cj75tmhvu000roa5xzaly64wv","tag_id":"cj74dxevx001alr011jalrjad","_id":"cj75tmhvv000soa5xqmouuzmc"},{"post_id":"cj75tmhvw000toa5xahn3iibz","tag_id":"cj74dxevj000plr01ad165f8g","_id":"cj75tmhvx000uoa5xkx1kheun"},{"post_id":"cj75tmhvy000voa5xmjalv807","tag_id":"cj74dxevx0019lr01x0b8v0pn","_id":"cj75tmhvy000woa5xyp8fp8ow"},{"post_id":"cj75tmhvy000voa5xmjalv807","tag_id":"cj74dxevx001alr011jalrjad","_id":"cj75tmhvz000xoa5xuazm2goq"},{"post_id":"cj75tmhvz000yoa5xo4u5ja7s","tag_id":"cj74dxevs0011lr01nkz20rq4","_id":"cj75tmhw1000zoa5x30ucu4u1"},{"post_id":"cj75tmhw10010oa5xp51sfclp","tag_id":"cj74dxevb000dlr01xthbr8eb","_id":"cj75tmhw30011oa5x2l2jt9ah"},{"post_id":"cj75tmhw40012oa5xo6sll49l","tag_id":"cj74dxevb000dlr01xthbr8eb","_id":"cj75tmhw40013oa5xrwwa19vg"},{"post_id":"cj75tmhw50014oa5xsug5gyfq","tag_id":"cj74dxevx0019lr01x0b8v0pn","_id":"cj75tmhw60015oa5x9uc8ugwr"},{"post_id":"cj75tmhw70016oa5x0cnxt0ej","tag_id":"cj74dxets0001lr01a616adon","_id":"cj75tmhw80017oa5xeb11wzt9"},{"post_id":"cj75tmhw90018oa5xx48ygysa","tag_id":"cj74dxets0001lr01a616adon","_id":"cj75tmhwa0019oa5xgkoycjyu"},{"post_id":"cj75tmhw90018oa5xx48ygysa","tag_id":"cj74dxewj0025lr01cny3jfqh","_id":"cj75tmhwa001aoa5xt6k4achb"},{"post_id":"cj75v3sig0000uz5x4w0rgsu3","tag_id":"cj75v3sip0001uz5xagvhw2lb","_id":"cj75v3sj40002uz5xr9yosktp"},{"post_id":"cj75tmhsg0000oa5x7blttoma","tag_id":"cj74dxets0001lr01a616adon","_id":"cj78n6rwo0000iw014spk8h49"},{"post_id":"cj8srx0o10000ig380nzhy8ae","tag_id":"cj74dxevx0019lr01x0b8v0pn","_id":"cj8srx0o70001ig38mukmxygt"}],"Tag":[{"name":"Java","_id":"cj74dxets0001lr01a616adon"},{"name":"Socket","_id":"cj74dxetv0002lr01xfxt2hl1"},{"name":"Git","_id":"cj74dxeva000alr01nyc8lexh"},{"name":"Mac","_id":"cj74dxevb000dlr01xthbr8eb"},{"name":"icodeyou","_id":"cj74dxevd000glr019rgnqrqq"},{"name":"设计模式","_id":"cj74dxevf000jlr01gvw776gg"},{"name":"数据结构","_id":"cj74dxevh000mlr01z4kydv8t"},{"name":"数据结构与算法","_id":"cj74dxevj000plr01ad165f8g"},{"name":"Android","_id":"cj74dxevl000slr0102amh81w"},{"name":"Python","_id":"cj74dxevs0011lr01nkz20rq4"},{"name":"TCP","_id":"cj74dxevu0014lr01j9zrwbap"},{"name":"netwox","_id":"cj74dxevu0015lr01p6m3294k"},{"name":"Linux","_id":"cj74dxevx0019lr01x0b8v0pn"},{"name":"Wireshark","_id":"cj74dxevx001alr011jalrjad"},{"name":"算法","_id":"cj74dxew1001glr01fygr37z0"},{"name":"Mysql","_id":"cj74dxew9001plr01101gda6g"},{"name":"GBN","_id":"cj74dxewd001vlr01076jsmy9"},{"name":"路由算法","_id":"cj74dxewg001zlr01st121hbq"},{"name":"迪杰斯特拉","_id":"cj74dxewg0020lr015bfdhesy"},{"name":"AES","_id":"cj74dxewj0025lr01cny3jfqh"},{"name":"SMTP","_id":"cj74dxews002blr01m6lyytt2"},{"name":"Jenkins","_id":"cj75v3sip0001uz5xagvhw2lb"},{"name":"JavaScript","_id":"cj7eis9od0001w1383xqne8a6"}]}}